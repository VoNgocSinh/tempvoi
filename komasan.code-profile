{"name":"temp-voi","settings":"{\"settings\":\"{\\r\\n    \\\"chatgpt.lang\\\": \\\"en\\\",\\r\\n    \\\"code-runner.runInTerminal\\\": true,\\r\\n    \\\"editor.cursorSmoothCaretAnimation\\\": \\\"on\\\",\\r\\n    \\\"terminal.integrated.smoothScrolling\\\": true,\\r\\n    \\\"window.zoomLevel\\\": 1,\\r\\n    \\\"git.autofetch\\\": true,\\r\\n    \\\"liveServer.settings.donotShowInfoMsg\\\": true,\\r\\n    \\\"remote.SSH.remotePlatform\\\": {\\r\\n        \\\"itlethuy.ddns.net\\\": \\\"linux\\\",\\r\\n        \\\"ltoj.ddns.net\\\": \\\"linux\\\"\\r\\n    },\\r\\n    \\\"cloudcode.duetAI.project\\\": \\\"hihi-428305\\\",\\r\\n    \\\"cloudcode.duetAI.inlineSuggestions.enableAuto\\\": false,\\r\\n    \\\"workbench.editorAssociations\\\": {\\r\\n        \\\"*.pyc\\\": \\\"default\\\",\\r\\n        \\\"*.xlsx\\\": \\\"default\\\"\\r\\n    },\\r\\n    \\\"editor.fontLigatures\\\": true,\\r\\n    \\\"editor.fontFamily\\\": \\\"Jetbrains Mono, Consolas, 'Courier New', monospace\\\",\\r\\n    \\\"workbench.colorCustomizations\\\": {\\r\\n        \\\"terminal.background\\\": \\\"#00000000\\\"\\r\\n    },\\r\\n    \\\"workbench.settings.applyToAllProfiles\\\": [\\r\\n        \\\"workbench.colorCustomizations\\\"\\r\\n    ],\\r\\n    \\\"workbench.colorTheme\\\": \\\"Default Dark+\\\",\\r\\n    \\\"window.titleBarStyle\\\": \\\"custom\\\"\\r\\n}\"}","snippets":"{\"snippets\":{\"AhoCorasick.code-snippets\":\"{\\r\\n\\\"String - AhoCorasick\\\": {\\r\\n  \\\"prefix\\\": \\\"String - AhoCorasick\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"const int maxChar = 26;\\\",\\r\\n    \\\"struct AhoCorasick {\\\",\\r\\n    \\\"    struct node {\\\",\\r\\n    \\\"        int suffixLink, exitLink, cnt, nxt[maxChar];\\\",\\r\\n    \\\"        vector<int> index;\\\",\\r\\n    \\\"        node () {\\\",\\r\\n    \\\"            suffixLink = -1, exitLink = -1, cnt = 0;\\\",\\r\\n    \\\"            memset(nxt, -1, sizeof(nxt));\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"    };    \\\",\\r\\n    \\\" \\\",\\r\\n    \\\"    vector<node> v = {node()};\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"    void insert(string s, int pos) {\\\",\\r\\n    \\\"        int p = 0;\\\",\\r\\n    \\\"        for (int i = 0; i < s.size(); i++) {\\\",\\r\\n    \\\"            if (v[p].nxt[s[i] - 'a'] == -1) {\\\",\\r\\n    \\\"                v[p].nxt[s[i] - 'a'] = v.size();\\\",\\r\\n    \\\"                v.emplace_back();\\\",\\r\\n    \\\"            }\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"            p = v[p].nxt[s[i] - 'a'];\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"        v[p].cnt++;\\\",\\r\\n    \\\"        v[p].index.push_back(pos);\\\",\\r\\n    \\\"    }   \\\",\\r\\n    \\\" \\\",\\r\\n    \\\"    void buildAutomaton() {\\\",\\r\\n    \\\"        queue<int> q;\\\",\\r\\n    \\\"        q.push(0);\\\",\\r\\n    \\\"        \\\",\\r\\n    \\\"        while (!q.empty()) {\\\",\\r\\n    \\\"            int p = q.front();\\\",\\r\\n    \\\"            q.pop();\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"            int suffixLink = v[p].suffixLink;\\\",\\r\\n    \\\"            if (p)\\\",\\r\\n    \\\"                v[p].exitLink = (v[suffixLink].cnt ? suffixLink : v[suffixLink].exitLink);\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"            for (int i = 0; i < maxChar; i++) {\\\",\\r\\n    \\\"                int nxt = v[p].nxt[i];\\\",\\r\\n    \\\"                if (nxt != -1) {\\\",\\r\\n    \\\"                    v[nxt].suffixLink = (p == 0 ? 0 : v[v[p].suffixLink].nxt[i]);\\\",\\r\\n    \\\"                    q.push(nxt);\\\",\\r\\n    \\\"                } else\\\",\\r\\n    \\\"                    v[p].nxt[i] = (p == 0 ? 0 : v[v[p].suffixLink].nxt[i]);\\\",\\r\\n    \\\"            }\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"    } \\\",\\r\\n    \\\" \\\",\\r\\n    \\\"    vector<int> getIndex(int p) {\\\",\\r\\n    \\\"        vector<int> result;\\\",\\r\\n    \\\"        for (int i = v[p].cnt ? p : v[p].exitLink; i >= 0; i = v[i].exitLink)\\\",\\r\\n    \\\"            for (int x : v[i].index)\\\",\\r\\n    \\\"                result.push_back(x);\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"        return result;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"} ac;\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"String - AhoCorasick\\\"\\r\\n}\\r\\n}\",\"Bcc.code-snippets\":\"{\\n\\\"Graph - BCC\\\": {\\n  \\\"prefix\\\": \\\"Graph - BCC\\\",\\n  \\\"body\\\": [\\n    \\\"struct BiconnectedComponent {\\\",\\n    \\\"  vector<int> low, num, s;\\\",\\n    \\\"  vector< vector<int> > components;\\\",\\n    \\\"  int counter;\\\",\\n    \\\"\\\",\\n    \\\"  BiconnectedComponent() : num(n, -1), low(n, -1), counter(0) {\\\",\\n    \\\"    for (int i = 0; i < n; i++)\\\",\\n    \\\"      if (num[i] < 0)\\\",\\n    \\\"        dfs(i, 1);\\\",\\n    \\\"  }\\\",\\n    \\\"\\\",\\n    \\\"  void dfs(int x, int isRoot) {\\\",\\n    \\\"    low[x] = num[x] = ++counter;\\\",\\n    \\\"    if (a[x].empty()) {\\\",\\n    \\\"      components.push_back(vector<int>(1, x));\\\",\\n    \\\"      return;\\\",\\n    \\\"    }\\\",\\n    \\\"    s.push_back(x);\\\",\\n    \\\"\\\",\\n    \\\"    for (int i = 0; i < a[x].size(); i++) {\\\",\\n    \\\"      int y = a[x][i];\\\",\\n    \\\"      if (num[y] > -1) low[x] = min(low[x], num[y]);\\\",\\n    \\\"      else {\\\",\\n    \\\"        dfs(y, 0);\\\",\\n    \\\"        low[x] = min(low[x], low[y]);\\\",\\n    \\\"\\\",\\n    \\\"        if (isRoot || low[y] >= num[x]) {\\\",\\n    \\\"          components.push_back(vector<int>(1, x));\\\",\\n    \\\"          while (1) {\\\",\\n    \\\"            int u = s.back();\\\",\\n    \\\"            s.pop_back();\\\",\\n    \\\"            components.back().push_back(u);\\\",\\n    \\\"            if (u == y) break;\\\",\\n    \\\"          }\\\",\\n    \\\"        }\\\",\\n    \\\"      }\\\",\\n    \\\"    }\\\",\\n    \\\"  }\\\",\\n    \\\"};\\\"\\n  ],\\n  \\\"description\\\": \\\"Graph - BCC\\\"\\n}\\n}\",\"CCW.code-snippets\":\"{\\n\\\"Geometry - CCW\\\": {\\n  \\\"prefix\\\": \\\"Geometry - CCW\\\",\\n  \\\"body\\\": [\\n    \\\"long double cww(point A, point B, point C) {\\\",\\n    \\\"    return (B.x - A.x) * (C.y - A.y) - (C.x - A.x) * (B.y - A.y);\\\",\\n    \\\"}\\\"\\n  ],\\n  \\\"description\\\": \\\"Geometry - CCW\\\"\\n}\\n}\",\"CentroidDecomposition.code-snippets\":\"{\\r\\n\\\"Graph - CentroidDecomposition\\\": {\\r\\n  \\\"prefix\\\": \\\"Graph - Centroid\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"struct CentroidDecomposition {\\\",\\r\\n    \\\"    int maxh, cnt[N], del[N], child[N];\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    void countChild(int u, int par) {\\\",\\r\\n    \\\"        child[u] = 1;\\\",\\r\\n    \\\"        for (int x : edge[u])\\\",\\r\\n    \\\"            if (x != par && !del[x]) {\\\",\\r\\n    \\\"                countChild(x, u);\\\",\\r\\n    \\\"                child[u] += child[x];\\\",\\r\\n    \\\"            } \\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    int centroid(int u, int par, int n) {\\\",\\r\\n    \\\"        for (int x : edge[u])\\\",\\r\\n    \\\"            if (x != par && !del[x] && child[x] > n / 2)\\\",\\r\\n    \\\"                return centroid(x, u, n); \\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        return u;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    void dfs(int u, int par, int type) {\\\",\\r\\n    \\\"        if (type) {\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"            //...\\\",\\r\\n    \\\"        } else {\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"            //...\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    void solve(int u) {\\\",\\r\\n    \\\"        countChild(u, -1);\\\",\\r\\n    \\\"        int n = child[u];\\\",\\r\\n    \\\"        int root = centroid(u, -1, n);\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        for (int x : edge[root])\\\",\\r\\n    \\\"            if (!del[x]) {\\\",\\r\\n    \\\"                dfs(x, root, 0);\\\",\\r\\n    \\\"                dfs(x, root, 1);\\\",\\r\\n    \\\"            }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        del[root] = 1;\\\",\\r\\n    \\\"        for (int x : edge[root])\\\",\\r\\n    \\\"            if (!del[x]) solve(x);\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"} centroid;\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Graph - CentroidDecomposition\\\"\\r\\n}\\r\\n}\",\"ChuTrinhDon.code-snippets\":\"{\\n\\\"Graph - ChuTrinhDon\\\": {\\n  \\\"prefix\\\": \\\"Graph - ChuTrinhDon\\\",\\n  \\\"body\\\": [\\n    \\\"#include <algorithm>\\\",\\n    \\\"#include <iostream>\\\",\\n    \\\"#include <vector>\\\",\\n    \\\" \\\",\\n    \\\"using namespace std;\\\",\\n    \\\" \\\",\\n    \\\"vector<vector<int>> graph;\\\",\\n    \\\"vector<bool> visited, on_stack;\\\",\\n    \\\"vector<int> cycle;\\\",\\n    \\\" \\\",\\n    \\\"bool dfs(int node) {\\\",\\n    \\\"\\tvisited[node] = on_stack[node] = true;\\\",\\n    \\\"\\tfor (int next : graph[node]) {\\\",\\n    \\\"\\t\\tif (on_stack[next]) {\\\",\\n    \\\"\\t\\t\\tcycle.push_back(node);  // start cycle\\\",\\n    \\\"\\t\\t\\ton_stack[node] = on_stack[next] = false;\\\",\\n    \\\"\\t\\t\\treturn true;\\\",\\n    \\\"\\t\\t} else if (!visited[next]) {\\\",\\n    \\\"\\t\\t\\tif (dfs(next)) {  // continue cycle\\\",\\n    \\\"\\t\\t\\t\\tif (on_stack[node]) {\\\",\\n    \\\"\\t\\t\\t\\t\\tcycle.push_back(node);\\\",\\n    \\\"\\t\\t\\t\\t\\ton_stack[node] = false;\\\",\\n    \\\"\\t\\t\\t\\t\\treturn true;\\\",\\n    \\\"\\t\\t\\t\\t} else {  // found u again\\\",\\n    \\\"\\t\\t\\t\\t\\tcycle.push_back(node);\\\",\\n    \\\"\\t\\t\\t\\t\\treturn false;\\\",\\n    \\\"\\t\\t\\t\\t}\\\",\\n    \\\"\\t\\t\\t}\\\",\\n    \\\" \\\",\\n    \\\"\\t\\t\\tif (!cycle.empty()) {\\\",\\n    \\\"\\t\\t\\t\\treturn false;  // finished with cycle\\\",\\n    \\\"\\t\\t\\t}\\\",\\n    \\\"\\t\\t}\\\",\\n    \\\"\\t}\\\",\\n    \\\" \\\",\\n    \\\"\\ton_stack[node] = false;\\\",\\n    \\\"\\treturn false;\\\",\\n    \\\"}\\\",\\n    \\\" \\\",\\n    \\\"int main() {\\\",\\n    \\\"\\tint n, m;\\\",\\n    \\\"\\tcin >> n >> m;\\\",\\n    \\\"\\tgraph = vector<vector<int>>(n);\\\",\\n    \\\"\\tfor (int i = 0; i < m; i++) {\\\",\\n    \\\"\\t\\tint a, b;\\\",\\n    \\\"\\t\\tcin >> a >> b;\\\",\\n    \\\"\\t\\tgraph[a - 1].push_back(b - 1);\\\",\\n    \\\"\\t}\\\",\\n    \\\" \\\",\\n    \\\"\\tvisited = vector<bool>(n);\\\",\\n    \\\"\\ton_stack = vector<bool>(n);\\\",\\n    \\\"\\tfor (int i = 0; cycle.empty() && i < n; i++) { dfs(i); }\\\",\\n    \\\" \\\",\\n    \\\"\\tif (cycle.empty()) {\\\",\\n    \\\"\\t\\tcout << \\\\\\\"IMPOSSIBLE\\\\\\\" << endl;\\\",\\n    \\\"\\t} else {\\\",\\n    \\\"\\t\\treverse(cycle.begin(), cycle.end());\\\",\\n    \\\"\\t\\tcout << cycle.size() + 1 << \\\\\\\"\\\\\\\\n\\\\\\\";\\\",\\n    \\\"\\t\\tfor (int node : cycle) { cout << node + 1 << \\\\\\\" \\\\\\\"; }\\\",\\n    \\\"\\t\\tcout << cycle[0] + 1 << endl;\\\",\\n    \\\"\\t}\\\",\\n    \\\"}\\\"\\n  ],\\n  \\\"description\\\": \\\"Graph - ChuTrinhDon\\\"\\n}\\n}\",\"ConvexHull.code-snippets\":\"{\\r\\n\\\"Geometry - ConvexHull\\\": {\\r\\n  \\\"prefix\\\": \\\"Geometry - ConvexHull\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"vector<point> convexHull(vector<point> p, int n) {\\\",\\r\\n    \\\"    sort(p.begin(), p.end(), [](const point &A, const point &B) {\\\",\\r\\n    \\\"        if (A.x != B.x)\\\",\\r\\n    \\\"            return A.x < B.x;\\\",\\r\\n    \\\"        return A.y < B.y;\\\",\\r\\n    \\\"    });\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"    vector<point> hull;\\\",\\r\\n    \\\"    hull.push_back(p[0]);    \\\",\\r\\n    \\\" \\\",\\r\\n    \\\"    for (int i = 1; i < n; i++) {\\\",\\r\\n    \\\"        while (hull.size() > 1 && cww(hull[hull.size() - 2], hull[hull.size() - 1], p[i]) > 0) hull.pop_back();\\\",\\r\\n    \\\"        hull.push_back(p[i]);\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"    for (int i = n - 2; i >= 0; i--) {\\\",\\r\\n    \\\"        while (hull.size() > 1 && cww(hull[hull.size() - 2], hull[hull.size() - 1], p[i]) > 0) hull.pop_back();\\\",\\r\\n    \\\"        hull.push_back(p[i]);\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"    if (hull.size() > 1)\\\",\\r\\n    \\\"        hull.pop_back();\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"    return hull;\\\",\\r\\n    \\\"}\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Geometry - ConvexHull\\\"\\r\\n}\\r\\n}\",\"ConvexHullTrick.code-snippets\":\"{\\r\\n\\\"Data Structures - ConvexHullTrick\\\": {\\r\\n  \\\"prefix\\\": \\\"Data Structures - ConvexHullTrick\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"struct line {\\\",\\r\\n    \\\"    long long a, b, x;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    line() : a(0), b(1e9), x(-1e9) {};\\\",\\r\\n    \\\"    line(long long a, long long b) : a(a), b(b), x(-1e9) {};        \\\",\\r\\n    \\\"    line(long long a, long long b, long long x) : a(a), b(b), x(x) {};        \\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    long long operator() (long long x) {\\\",\\r\\n    \\\"        return a * x + b;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"};\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"namespace CHT {\\\",\\r\\n    \\\"    bool canDel(line A, line B, line C) {\\\",\\r\\n    \\\"        return (A.b - C.b) * (C.a - B.a) < (B.b - C.b) * (C.a - A.a);\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    vector<line> Line;\\\",\\r\\n    \\\"    void addLine(line newLine) {\\\",\\r\\n    \\\"        if (Line.empty())\\\",\\r\\n    \\\"            return void(Line.push_back(newLine));\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        if (Line.back().a == newLine.a)\\\",\\r\\n    \\\"            return;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        while (Line.size() > 1 && canDel(Line[Line.size() - 1], Line[Line.size() - 2], newLine))\\\",\\r\\n    \\\"            Line.pop_back();\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        newLine.x = (int)((Line.back().b - newLine.b) / (newLine.a - Line.back().a));\\\",\\r\\n    \\\"        Line.push_back(newLine);\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    int getQuery(int x) {\\\",\\r\\n    \\\"        int l = 0, r = Line.size() - 1;\\\",\\r\\n    \\\"        while (l < r) {\\\",\\r\\n    \\\"            int mid = l + r >> 1;\\\",\\r\\n    \\\"            if (Line[mid](x) >= Line[mid + 1](x))\\\",\\r\\n    \\\"                l = mid + 1;\\\",\\r\\n    \\\"            else\\\",\\r\\n    \\\"                r = mid;\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        return Line[l](x);\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"}\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Data Structures - ConvexHullTrick\\\"\\r\\n}\\r\\n}\",\"DegToRad.code-snippets\":\"{\\n\\\"Geometry - DegToRad\\\": {\\n  \\\"prefix\\\": \\\"Geometry - DegToRad\\\",\\n  \\\"body\\\": [\\n    \\\"inline double Deg_to_Rad(double deg) {return deg / 180 * PI;}\\\"\\n  ],\\n  \\\"description\\\": \\\"Geometry - DegToRad\\\"\\n}\\n}\",\"Dijkstra.code-snippets\":\"{\\n\\\"Graph - Dijkstra\\\": {\\n  \\\"prefix\\\": \\\"Graph - Dijkstra\\\",\\n  \\\"body\\\": [\\n    \\\"int dist[N];\\\",\\n    \\\"void dijkstra(int u, int * dist) {\\\",\\n    \\\"    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq; \\\",\\n    \\\"    for (int i = 1; i <= n; i++)\\\",\\n    \\\"        dist[i] = (i == u ? 0 : INF);\\\",\\n    \\\"    pq.push(make_pair(0, u));\\\",\\n    \\\" \\\",\\n    \\\"    while (!pq.empty()) {\\\",\\n    \\\"        int u = pq.top().se, d = pq.top().fi; pq.pop();\\\",\\n    \\\"        if (d > dist[u])\\\",\\n    \\\"            continue;\\\",\\n    \\\" \\\",\\n    \\\"        for (pair<int, int> x : edge[u])\\\",\\n    \\\"            if (dist[x.fi] > d + x.se) {\\\",\\n    \\\"                dist[x.fi] = d + x.se;\\\",\\n    \\\"                pq.push(make_pair(dist[x.fi], x.fi));\\\",\\n    \\\"            }\\\",\\n    \\\"    }\\\",\\n    \\\"}\\\",\\n  ],\\n  \\\"description\\\": \\\"Graph - Dijkstra\\\"\\n}\\n}\",\"DisjointSetUnion(Heavy Light Set).code-snippets\":\"{\\r\\n\\\"Graph - DisjointSetUnion(Heavy Light Set)\\\": {\\r\\n  \\\"prefix\\\": \\\"Graph - DSU(Heavy Light Set)\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"struct DisjointSetUnion {\\\",\\r\\n    \\\"    int Par[N];\\\",\\r\\n    \\\"    vector<int> a[N];\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    void init(int n) {\\\",\\r\\n    \\\"        for (int i = 1; i <= n; i++) {\\\",\\r\\n    \\\"            a[i].clear();\\\",\\r\\n    \\\"            a[i].push_back(i);\\\",\\r\\n    \\\"            Par[i] = i;\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    bool join(int u, int v) {\\\",\\r\\n    \\\"        if (Par[u] == Par[v])\\\",\\r\\n    \\\"            return false;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        u = Par[u];\\\",\\r\\n    \\\"        v = Par[v];\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        if (a[u].size() < a[v].size())\\\",\\r\\n    \\\"            swap(u, v);\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        for (int x : a[v]) {\\\",\\r\\n    \\\"            a[u].push_back(x);\\\",\\r\\n    \\\"            Par[x] = u;\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        return true;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"} DSU;\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Graph - DisjointSetUnion(Heavy Light Set)\\\"\\r\\n}\\r\\n}\",\"DisjointSetUnion(Rollback).code-snippets\":\"{\\r\\n\\\"Graph - DisjointSetUnion Rollback\\\": {\\r\\n  \\\"prefix\\\": \\\"Graph - DSU(Rollback)\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"struct DisjointSetUnion {\\\",\\r\\n    \\\"    int Par[N], sz[N];\\\",\\r\\n    \\\"    vector<int> s;\\\",\\r\\n    \\\"    int num, cnt;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    void init(int n) {\\\",\\r\\n    \\\"        num = n, s.clear();\\\",\\r\\n    \\\"        for (int i = 1; i <= n; i++)\\\",\\r\\n    \\\"            Par[i] = i, sz[i] = 1;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    int find(int u) {\\\",\\r\\n    \\\"        return u == Par[u] ? u : find(Par[u]);\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    bool merge(int u, int v) {\\\",\\r\\n    \\\"        u = find(u), v = find(v);\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        if (u == v) \\\",\\r\\n    \\\"            return false;\\\",\\r\\n    \\\"       \\\",\\r\\n    \\\"        if (sz[u] > sz[v]) \\\",\\r\\n    \\\"            swap(u, v);\\\",\\r\\n    \\\"        \\\",\\r\\n    \\\"        Par[u] = v, sz[v] += sz[u], s.push_back(u), num--, cnt++;\\\",\\r\\n    \\\"       \\\",\\r\\n    \\\"        return true;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    void undo(int t) {\\\",\\r\\n    \\\"        while (s.size() > t) {\\\",\\r\\n    \\\"            int u = s.back();\\\",\\r\\n    \\\"            s.pop_back();\\\",\\r\\n    \\\"            sz[Par[u]] -= sz[u];\\\",\\r\\n    \\\"            Par[u] = u;\\\",\\r\\n    \\\"            num++;\\\",\\r\\n    \\\"            cnt--;\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"} DSU;\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Graph - DisjointSetUnion Rollback\\\"\\r\\n}\\r\\n}\",\"DisjointSetUnion.code-snippets\":\"{\\r\\n  \\\"Graph - DSU\\\": {\\r\\n  \\\"prefix\\\": \\\"Graph - DSU\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"struct DisjointSetUnion {\\\",\\r\\n    \\\"    int parent[N], sz[N];\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    void make_set(int v) {\\\",\\r\\n    \\\"        parent[v] = v;\\\",\\r\\n    \\\"        sz[v] = 1;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    void prepare(int n) {\\\",\\r\\n    \\\"        for (int i = 1; i <= n; i++)\\\",\\r\\n    \\\"            make_set(i);\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    int find(int v) {\\\",\\r\\n    \\\"        return v == parent[v] ? v : parent[v] = find(parent[v]);\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    bool join(int a, int b) {\\\",\\r\\n    \\\"        a = find(a);\\\",\\r\\n    \\\"        b = find(b);\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        if (a == b) \\\",\\r\\n    \\\"            return false;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        if (sz[a] < sz[b]) swap(a,b);\\\",\\r\\n    \\\"        parent[b] = a;\\\",\\r\\n    \\\"        sz[a] += sz[b];\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        return true;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"} DSU;\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Graph - DSU\\\"\\r\\n}\\r\\n}\",\"DuongDiEuler.code-snippets\":\"{\\n\\\"Graph - DuongDiEuler\\\": {\\n  \\\"prefix\\\": \\\"Graph - DuongDiEuler\\\",\\n  \\\"body\\\": [\\n    \\\"#include<bits/stdc++.h>\\\",\\n    \\\"using namespace std;\\\",\\n    \\\"\\\",\\n    \\\"#define           ios ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\\\",\\n    \\\"#define     inpout(a) freopen(a\\\\\\\".inp\\\\\\\",\\\\\\\"r\\\\\\\",stdin),freopen(a\\\\\\\".out\\\\\\\",\\\\\\\"w\\\\\\\",stdout)\\\",\\n    \\\" \\\",\\n    \\\"template<class A,class B> inline void maximize(A& x, B y) {x = max(x, y);};\\\",\\n    \\\"template<class A,class B> inline void minimize(A& x, B y) {x = min(x, y);};\\\",\\n    \\\" \\\",\\n    \\\"const int N = 2e5 + 100;\\\",\\n    \\\" \\\",\\n    \\\"int n, m, deg[N];\\\",\\n    \\\"set<int> edge[N];\\\",\\n    \\\"vector<int> path;\\\",\\n    \\\" \\\",\\n    \\\"bool eulerPath() {\\\",\\n    \\\"    for (int i = 1; i <= n; i++)\\\",\\n    \\\"        if (deg[i] % 2)\\\",\\n    \\\"            return false;\\\",\\n    \\\"    \\\",\\n    \\\"    stack<int> P;\\\",\\n    \\\"    P.push(1);\\\",\\n    \\\"    while (P.size()) {\\\",\\n    \\\"        int u = P.top();\\\",\\n    \\\"        if (edge[u].empty()) {\\\",\\n    \\\"            P.pop();\\\",\\n    \\\"            path.push_back(u);\\\",\\n    \\\"        } else {\\\",\\n    \\\"            int v = *edge[u].begin();\\\",\\n    \\\"            P.push(v);\\\",\\n    \\\"            edge[v].erase(u);\\\",\\n    \\\"            edge[u].erase(v);\\\",\\n    \\\"        }\\\",\\n    \\\"    }\\\",\\n    \\\" \\\",\\n    \\\"    return (path.size() == m + 1);\\\",\\n    \\\"}\\\",\\n    \\\" \\\",\\n    \\\"void komasan() {\\\",\\n    \\\"    cin >> n >> m;\\\",\\n    \\\"    for (int i = 1; i <= m; i++) {\\\",\\n    \\\"        int u, v;\\\",\\n    \\\"        cin >> u >> v;\\\",\\n    \\\"        edge[u].insert(v);\\\",\\n    \\\"        edge[v].insert(u);\\\",\\n    \\\"        deg[u]++;\\\",\\n    \\\"        deg[v]++;\\\",\\n    \\\"    }\\\",\\n    \\\" \\\",\\n    \\\"    if (!eulerPath())\\\",\\n    \\\"        cout << \\\\\\\"IMPOSSIBLE\\\\\\\";\\\",\\n    \\\"    else {\\\",\\n    \\\"        for (int x : path)\\\",\\n    \\\"            cout << x << ' ';\\\",\\n    \\\"    }\\\",\\n    \\\"}\\\",\\n    \\\" \\\",\\n    \\\"int main() {\\\",\\n    \\\"    ios;\\\",\\n    \\\"    //inpout(\\\\\\\"\\\\\\\");\\\",\\n    \\\"    komasan();\\\",\\n    \\\"}\\\"\\n  ],\\n  \\\"description\\\": \\\"Graph - DuongDiEuler\\\"\\n}\\n}\",\"EuclidDistance.code-snippets\":\"{\\n\\\"Geometry - EuclidDistance\\\": {\\n  \\\"prefix\\\": \\\"Geometry - EuclidDistance\\\",\\n  \\\"body\\\": [\\n    \\\"double EuclidDistance(point A, point B) {\\\",\\n    \\\"    return sqrt((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y));\\\",\\n    \\\"}\\\"\\n  ],\\n  \\\"description\\\": \\\"Geometry - EuclidDistance\\\"\\n}\\n}\",\"FastPow.code-snippets\":\"{\\r\\n\\\"Math - FastPow\\\": {\\r\\n  \\\"prefix\\\": \\\"Math - FastPow\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"int Pw(int a, auto n, int mod) {\\\",\\r\\n    \\\"    int s = 1;\\\",\\r\\n    \\\"    while(n) {\\\",\\r\\n    \\\"        if (n & 1) \\\",\\r\\n    \\\"            s = 1ll * s * a % mod;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        n >>= 1, a = 1ll * a * a % mod;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"   \\\",\\r\\n    \\\"    return s;\\\",\\r\\n    \\\"}\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Math - FastPow\\\"\\r\\n}\\r\\n}\",\"FenwickTree.code-snippets\":\"{\\r\\n\\\"Data - Structures FenwickTree\\\": {\\r\\n  \\\"prefix\\\": \\\"Data Structures - FenwickTree\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"struct fenwickTree {\\\",\\r\\n    \\\"    int n;\\\",\\r\\n    \\\"    vector<int> bit;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    fenwickTree(int n) : n(n), bit(vector<int>(n + 1, 0)) {};\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    void update(int u, int val) {\\\",\\r\\n    \\\"        int idx = u;\\\",\\r\\n    \\\"        while (idx <= n) {\\\",\\r\\n    \\\"            bit[idx] += val;\\\",\\r\\n    \\\"            idx += (idx & (-idx));\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    int get(int p) {\\\",\\r\\n    \\\"        int idx = p, ans = 0;\\\",\\r\\n    \\\"        while (idx > 0) {\\\",\\r\\n    \\\"            ans += bit[idx];\\\",\\r\\n    \\\"            idx -= (idx & (-idx));\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"        return ans;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    int get(int l, int r) {\\\",\\r\\n    \\\"        return get(r) - get(l - 1);\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"};\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Data - Structures FenwickTree\\\"\\r\\n}\\r\\n}\",\"FenwickTree2D.code-snippets\":\"{\\r\\n\\\"Data - Structures FenwickTree2D\\\": {\\r\\n  \\\"prefix\\\": \\\"Data Structures - FenwickTree2D\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"struct fenwickTree2D {\\\",\\r\\n    \\\"    int n, m;\\\",\\r\\n    \\\"    vector<vector<int>> bit;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    fenwickTree2D(int n, int m) : n(n), m(m), bit(vector<vector<int>>(n + 1, vector<int>(m + 1, 0))) {};\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    void update(int _x, int _y, int val) {\\\",\\r\\n    \\\"        for (int x = _x; x <= n; x += (x & (-x)))\\\",\\r\\n    \\\"            for (int y = _y; y <= m; y += (y & (-y)))\\\",\\r\\n    \\\"                bit[x][y] += val;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    int get(int _x, int _y) {\\\",\\r\\n    \\\"        int sum = 0;\\\",\\r\\n    \\\"        for (int x = _x; x; x -= (x & (-x)))\\\",\\r\\n    \\\"            for (int y = _y; y; y -= (y & (-y)))\\\",\\r\\n    \\\"                sum += bit[x][y];\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        return sum;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    int get(int x, int y, int u, int v) {\\\",\\r\\n    \\\"        return get(u, v) - get(x - 1, v) - get(u, y - 1) + get(x - 1, y - 1);\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"};\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Data - Structures FenwickTree2D\\\"\\r\\n}\\r\\n}\",\"GaussJordan.code-snippets\":\"{\\r\\n\\\"Math - GaussJordan\\\": {\\r\\n  \\\"prefix\\\": \\\"Math - GaussJordan\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"const int gssMod = 3;\\\",\\r\\n    \\\"bool gauss(vector<vector<int>> A, vector<int> &ans) {\\\",\\r\\n    \\\"    int n = (int)A.size(), m = (int)A[0].size() - 1;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    vector<int> p(m, -1);\\\",\\r\\n    \\\"    for (int row = 0, col = 0; row < n && col < m; col++) {\\\",\\r\\n    \\\"        for (int i = row; i < n; i++) {\\\",\\r\\n    \\\"            if (A[i][col]) {\\\",\\r\\n    \\\"                swap(A[row], A[i]);\\\",\\r\\n    \\\"                break;\\\",\\r\\n    \\\"            }\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        if (!A[row][col]) continue;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        p[col] = row;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        for (int i = 0; i < n; i++) {\\\",\\r\\n    \\\"            if (i == row) continue;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"            int c = (A[i][col] * A[row][col]) % gssMod;\\\",\\r\\n    \\\"            for (int j = col; j <= m; j++) {\\\",\\r\\n    \\\"                A[i][j] -= (A[row][j] * c) % gssMod;\\\",\\r\\n    \\\"                if (A[i][j] < 0) A[i][j] += gssMod;\\\",\\r\\n    \\\"            }\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        row++;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    ans.assign(m, 0);\\\",\\r\\n    \\\"    for (int i = 0; i < m; i++)\\\",\\r\\n    \\\"        if (p[i] != -1)\\\",\\r\\n    \\\"            ans[i] = (A[p[i]][m] * A[p[i]][i]) % gssMod;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    for (int i = 0; i < n; i++) {\\\",\\r\\n    \\\"        int sum = 0;\\\",\\r\\n    \\\"        for (int j = 0; j < m; j++) \\\",\\r\\n    \\\"            sum = (sum + ans[j] * A[i][j]) % gssMod;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        if (sum != A[i][m])\\\",\\r\\n    \\\"            return false; \\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"    \\\",\\r\\n    \\\"    return true;\\\",\\r\\n    \\\"}\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Math - GaussJordan\\\"\\r\\n}\\r\\n}\",\"Gen.code-snippets\":\"{\\r\\n\\\"Gen - Gen\\\": {\\r\\n  \\\"prefix\\\": \\\"Gen - Gen\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"@echo off\\\",\\r\\n    \\\"for /l %%i in (1, 1, 100000) do (\\\",\\r\\n    \\\"    test.exe > test.inp\\\",\\r\\n    \\\"    A.exe < test.inp > test.out\\\",\\r\\n    \\\"    B.exe < test.inp > answer.out\\\",\\r\\n    \\\"    fc test.out answer.out > 0 || echo TEST %%i [WA] && type test.inp && goto :out\\\",\\r\\n    \\\"    echo TEST %%i [AC]\\\",\\r\\n    \\\")\\\",\\r\\n    \\\":out\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Gen - Gen\\\"\\r\\n}\\r\\n}\",\"GeometreyLittleNoPro.code-snippets\":\"{\\n\\\"Geometry - LittleNoPro\\\": {\\n  \\\"prefix\\\": \\\"Geometry - LittleNoPro\\\",\\n  \\\"body\\\": [\\n    \\\"const db pi = acos(1);\\\",\\n    \\\"const int MOD = 1e9 + 19972207;\\\",\\n    \\\"const ll INF = 1e18;\\\",\\n    \\\"const int MAXN = 300005;\\\",\\n    \\\"const int EPS = 1e-9;\\\",\\n    \\\"\\\",\\n    \\\"struct point {\\\",\\n    \\\"    db x, y;\\\",\\n    \\\"    point() { x = y = 0.0; }\\\",\\n    \\\"    point(db _x, db _y) : x(_x), y(_y) {}\\\",\\n    \\\"    bool operator < (point other) const {\\\",\\n    \\\"        if(fabs(x - other.x) > EPS)\\\",\\n    \\\"            return x < other.x;\\\",\\n    \\\"        return y < other.y; }\\\",\\n    \\\"    bool operator == (point other) const {\\\",\\n    \\\"        return (fabs(x - other.x) < EPS && (fabs(y  - other.y) < EPS)); \\\",\\n    \\\"    }\\\",\\n    \\\"};\\\",\\n    \\\"\\\",\\n    \\\"db dist(point p1, point p2) {\\\",\\n    \\\"    return hypot(p1.x - p2.x, p1.y - p2.y);\\\",\\n    \\\"}\\\",\\n    \\\"\\\",\\n    \\\"db DEG_TO_RAD(db d) {\\\",\\n    \\\"    return d * pi / 180.0; \\\",\\n    \\\"}\\\",\\n    \\\"db RAD_TO_DEG(db d) {\\\",\\n    \\\"    return d * 180.0 / pi;\\\",\\n    \\\"}\\\",\\n    \\\"\\\",\\n    \\\"point rotation(point p, db alpha) {\\\",\\n    \\\"    db rad = DEG_TO_RAD(alpha);\\\",\\n    \\\"    return point(p.x * cos(rad) - p.y * sin(rad), p.x * sin(rad) + p.y * cos(rad));\\\",\\n    \\\"}\\\",\\n    \\\"\\\",\\n    \\\"point rotations(point p1, point p2, db alpha) {\\\",\\n    \\\"    db rad = DEG_TO_RAD(alpha);\\\",\\n    \\\"    point p3, p4;\\\",\\n    \\\"    p3.x = p1.x - p2.x;\\\",\\n    \\\"    p3.y = p1.y - p2.y;\\\",\\n    \\\"    p4 = point(p3.x * cos(rad) - p3.y * sin(rad), p3.x * sin(rad) + p3.y * cos(rad));\\\",\\n    \\\"    return point(p4.x + p2.x, p4.y + p2.y);\\\",\\n    \\\"}\\\",\\n    \\\"\\\",\\n    \\\"struct line {\\\",\\n    \\\"    db a, b, c;\\\",\\n    \\\"};\\\",\\n    \\\"\\\",\\n    \\\"line makeLine(point p1, point p2) {\\\",\\n    \\\"    line l1;\\\",\\n    \\\"    if(p1.x == p2.x) {\\\",\\n    \\\"        l1.a = 1;\\\",\\n    \\\"        l1.b = 0;\\\",\\n    \\\"        l1.c = - p1.x;\\\",\\n    \\\"    } else {\\\",\\n    \\\"        l1.a = (p2.y - p1.y) / (p1.x - p2.x);\\\",\\n    \\\"        l1.b = 1;\\\",\\n    \\\"        l1.c = - (l1.a) * p1.x - p1.y;\\\",\\n    \\\"    }\\\",\\n    \\\"    return l1;\\\",\\n    \\\"}\\\",\\n    \\\"\\\",\\n    \\\"bool Parallel(line l1, line l2) { // Kiem tra song song\\\",\\n    \\\"    return (l1.a == l2.a) && (l1.b == l2.b);\\\",\\n    \\\"}\\\",\\n    \\\"\\\",\\n    \\\"bool Same(line l1, line l2) { // kiem tra trung\\\",\\n    \\\"    return Parallel(l1, l2) && (l1.c == l2.c);\\\",\\n    \\\"}\\\",\\n    \\\"\\\",\\n    \\\"bool Intersect(line l1, line l2, point &p) { // kiem tra l1 co cat l2 hay ko\\\",\\n    \\\"    if(Parallel(l1, l2)) return false;\\\",\\n    \\\"    p.x = (l1.c * l2.b - l2.c * l1.b) / (l1.a * l2.b - l2.a * l1.b);\\\",\\n    \\\"    p.y = (l1.a * l2.c - l2.a * l1.c) / (l1.a * l2.b - l2.a * l1.b);\\\",\\n    \\\"    return true;\\\",\\n    \\\"}\\\",\\n    \\\"\\\",\\n    \\\"struct vect {\\\",\\n    \\\"    db x, y;\\\",\\n    \\\"    vect(db _x, db _y) {\\\",\\n    \\\"        x = _x;\\\",\\n    \\\"        y = _y;\\\",\\n    \\\"    }\\\",\\n    \\\"};\\\",\\n    \\\"\\\",\\n    \\\"vect operator + (const point &B, const point &A) {\\\",\\n    \\\"    return vect(B.x + A.x, B.y + A.y);\\\",\\n    \\\"}\\\",\\n    \\\"\\\",\\n    \\\"vect operator - (const point &B, const point &A) { // vecAB = B - A\\\",\\n    \\\"    return vect(B.x - A.x, B.y - A.y);\\\",\\n    \\\"}\\\",\\n    \\\"\\\",\\n    \\\"vect getVect(point a, point b) { // lay vector\\\",\\n    \\\"    return vect(b.x - a.x, b.y - a.y);\\\",\\n    \\\"}\\\",\\n    \\\"\\\",\\n    \\\"vect scale(vect v, db k) { // nhan vector voi 1 so nguyen k != 0\\\",\\n    \\\"    return vect(v.x * k, v.y * k);\\\",\\n    \\\"}\\\",\\n    \\\"\\\",\\n    \\\"point translate(point p, vect v) { // tinh tien diem p theo vector v\\\",\\n    \\\"    return point(v.x + p.x, v.y + p.y);\\\",\\n    \\\"}\\\",\\n    \\\"\\\",\\n    \\\"db getLength(vect v) { // do dai vector v\\\",\\n    \\\"    return hypot(v.x, v.y);\\\",\\n    \\\"}\\\",\\n    \\\"\\\",\\n    \\\"db sqrLen(vect v) { // binh phuong do dai vector\\\",\\n    \\\"    return v.x * v.x + v.y * v.y;\\\",\\n    \\\"}\\\",\\n    \\\"\\\",\\n    \\\"db scalar(vect v1, vect v2) { // tich vo huong 2 vector v1 va v2\\\",\\n    \\\"    return (v1.x * v2.x + v1.y * v2.y);\\\",\\n    \\\"}\\\",\\n    \\\"\\\",\\n    \\\"db cross(vect v1, vect v2) { // tich co huong 2 vector v1 va v2\\\",\\n    \\\"    return (v1.x * v2.y - v1.y * v2.x);\\\",\\n    \\\"}\\\",\\n    \\\"\\\",\\n    \\\"db getLength_sq(vect v) {\\\",\\n    \\\"    return v.x * v.x + v.y * v.y;\\\",\\n    \\\"}\\\",\\n    \\\"\\\",\\n    \\\"db distToLine(point p, point a, point b) {\\\",\\n    \\\"    vect AP = getVect(a, p), AB = getVect(a, b);\\\",\\n    \\\"    db k = scalar(AP, AB) / getLength_sq(AB);\\\",\\n    \\\"    point c = translate(a, scale(AB, k));\\\",\\n    \\\"    return dist(p, c);\\\",\\n    \\\"}\\\",\\n    \\\"\\\",\\n    \\\"db distToLineSegment(point p, point a, point b) {\\\",\\n    \\\"    vect AP = getVect(a, p), AB = getVect(a, b);\\\",\\n    \\\"    db k = scalar(AP, AB) / getLength_sq(AB);\\\",\\n    \\\"    if(k < 0.0) {\\\",\\n    \\\"        return dist(p, a);\\\",\\n    \\\"    }\\\",\\n    \\\"    if(k > 1.0) {\\\",\\n    \\\"        return dist(p, b);\\\",\\n    \\\"    }\\\",\\n    \\\"    return distToLine(p, a, b);\\\",\\n    \\\"}\\\",\\n    \\\"\\\",\\n    \\\"void FindFootOfTheAltitude(point A, point B, point C, point &cur) { // Tim toa do chan duong cao\\\",\\n    \\\"    line l = makeLine(B, C);\\\",\\n    \\\"    double ans = -(l.a * A.x + l.b * A.y + l.c) / (l.a * l.a + l.b * l.b);\\\",\\n    \\\"    cur.x = ans * l.a + A.x;\\\",\\n    \\\"    cur.y = ans * l.b + A.y;\\\",\\n    \\\"}\\\",\\n    \\\"\\\",\\n    \\\"db slope(point A, point B) { // Tim he co so\\\",\\n    \\\"    if(B.x - A.x != 0)\\\",\\n    \\\"        return (B.y - A.y) / (B.x - A.x);\\\",\\n    \\\"    return 1e8;\\\",\\n    \\\"}\\\",\\n    \\\"\\\",\\n    \\\"void FindIntersect(point A, point B, point C, point D, point &cur) {   // Tim toa do giao diem cua 2 doan thang\\\",\\n    \\\"    long double a1 = B.y - A.y;\\\",\\n    \\\"    long double b1 = A.x - B.x;\\\",\\n    \\\"    long double c1 = a1 * (A.x) + b1 * (A.y);\\\",\\n    \\\"    long double a2 = D.y - C.y;\\\",\\n    \\\"    long double b2 = C.x - D.x;\\\",\\n    \\\"    long double c2 = a2 * (C.x) + b2 * (C.y);\\\",\\n    \\\"    long double determinant = a1*b2 - a2*b1;\\\",\\n    \\\"    if(determinant == 0) {\\\",\\n    \\\"        cur.x = FLT_MAX;\\\",\\n    \\\"        cur.y = FLT_MAX;\\\",\\n    \\\"    }\\\",\\n    \\\"    else {\\\",\\n    \\\"        cur.x = 1.0*(b2*c1 - b1*c2)/determinant;\\\",\\n    \\\"        cur.y = 1.0*(a1*c2 - a2*c1)/determinant;\\\",\\n    \\\"    }\\\",\\n    \\\"}\\\",\\n    \\\"\\\",\\n    \\\"int CCW(point A, point B, point C) {\\\",\\n    \\\"    vect AB = getVect(A, B);\\\",\\n    \\\"    vect AC = getVect(A, C);\\\",\\n    \\\"    if(cross(AB, AC) > 0) \\\",\\n    \\\"        return 1;  // diem C nam phia tren doan thang AB\\\",\\n    \\\"    else\\\",\\n    \\\"    if(cross(AB, AC) < 0) \\\",\\n    \\\"        return -1; // diem C nam phia duoi doan thang AB\\\",\\n    \\\"    return 0; \\\",\\n    \\\"}\\\",\\n    \\\"\\\",\\n    \\\"map<pll, ll> res;\\\",\\n    \\\"int n, m;\\\",\\n    \\\"point q[MAXN], p[MAXN], A;\\\",\\n    \\\"\\\",\\n    \\\"bool CCWInConvexHull(const point& D, const point& E, const point& F){\\\",\\n    \\\"    return cross(E - D, F - E) > 0;\\\",\\n    \\\"}\\\",\\n    \\\"\\\",\\n    \\\"void GrahamScan(){\\\",\\n    \\\"    sort(p+1, p+n, [](const point& B, const point& C){\\\",\\n    \\\"        vect u = B - A, v = C - A;\\\",\\n    \\\"        ll temp = cross(u, v);\\\",\\n    \\\"        return temp > 0 || (temp == 0 && sqrLen(u) < sqrLen(v));\\\",\\n    \\\"    });\\\",\\n    \\\"}\\\",\\n    \\\"\\\",\\n    \\\"void BuildConvexHull(){\\\",\\n    \\\"    m = 0;\\\",\\n    \\\"    for(int i = 0; i < n; i++){\\\",\\n    \\\"        while (m >= 2 && !CCWInConvexHull(q[m - 2], q[m - 1], p[i]))\\\",\\n    \\\"            m--;\\\",\\n    \\\"        q[m++] = p[i];\\\",\\n    \\\"    }\\\",\\n    \\\"}\\\",\\n    \\\"\\\",\\n    \\\"db AreaOfTriangle(point c, point a, point b) {\\\",\\n    \\\"    return ((db) 1 / 2 * distToLineSegment(c, a, b) * dist(a, b));\\\",\\n    \\\"}\\\",\\n    \\\"\\\",\\n    \\\"long double Area(point A, point B, point C) {  // Tinh dien tich da giac voi toa do nguyen \\\",\\n    \\\"    return (long double) 0.5 * abs((B.x - A.x) * (C.y - A.y) - (C.x - A.x) * (B.y - A.y)); \\\",\\n    \\\"}\\\",\\n    \\\"\\\",\\n    \\\"db quadrilateral(const point& A, const point& B, const point& C, const point& D){\\\",\\n    \\\"    return abs(((A.x * B.y+B.x * C.y+C.x * D.y+D.x * A.y) - \\\",\\n    \\\"        (A.y * B.x+B.y * C.x+C.y * D.x+D.y * A.x))) / 2;\\\",\\n    \\\"}\\\"\\n  ],\\n  \\\"description\\\": \\\"Geometry - LittleNoPro\\\"\\n}\\n}\",\"Geometry.code-snippets\":\"{\\r\\n\\\"Geometry - Geometry\\\": {\\r\\n  \\\"prefix\\\": \\\"Geometry - Geometry\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"const long double PI = 3.14159265358979;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"struct point {\\\",\\r\\n    \\\"    double x, y;\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"    inline point() : x(0), y(0) {};\\\",\\r\\n    \\\"    inline point(double x, double y) : x(x), y(y) {};\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    bool operator < (point b) {return (x < b.x || (x == b.x && y < b.y));}\\\",\\r\\n    \\\"    bool operator > (point b) {return (x > b.x || (x == b.x && y > b.y));}\\\",\\r\\n    \\\"    bool operator == (point b) {return (x == b.x && y == b.y);}\\\",\\r\\n    \\\"    bool operator <= (point b) {return (x < b.x || (x == b.x && y <= b.y));}\\\",\\r\\n    \\\"    bool operator >= (point b) {return (x > b.x || (x == b.x && y >= b.y));}\\\",\\r\\n    \\\"};\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"inline double distance(point A, point B) {return sqrt((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y));}\\\",\\r\\n    \\\"inline double Rad_to_Deg(double rad) {return rad * 180 / PI;}\\\",\\r\\n    \\\"inline double Deg_to_Rad(double deg) {return deg / 180 * PI;}\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"point rotation(point p, double alpha) {\\\",\\r\\n    \\\"    double rad = Deg_to_Rad(alpha);\\\",\\r\\n    \\\"    return point(p.x * cos(rad) - p.y * sin(rad), p.x * sin(rad) + p.y * cos(rad));\\\",\\r\\n    \\\"}\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"point rotations(point p1, point p2, double alpha) {\\\",\\r\\n    \\\"    double rad = Deg_to_Rad(alpha);\\\",\\r\\n    \\\"    point p3 = point(p1.x - p2.x, p1.y - p2.y);\\\",\\r\\n    \\\"    point p4 = point(p3.x * cos(rad) - p3.y * sin(rad), p3.x * sin(rad) + p3.y * cos(rad));\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    return point(p4.x + p2.x, p4.y + p2.y);\\\",\\r\\n    \\\"}\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"long double cww(point A, point B, point C) {\\\",\\r\\n    \\\"    return (B.x - A.x) * (C.y - A.y) - (C.x - A.x) * (B.y - A.y);\\\",\\r\\n    \\\"}\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"struct line {\\\",\\r\\n    \\\"    double a, b, c;\\\",\\r\\n    \\\"    inline line () {a = b = c = 0;}\\\",\\r\\n    \\\"    inline line (double _a, double _b, double _c) {a = _a, b = _b, c = _c;}\\\",\\r\\n    \\\"};\\\",\\r\\n    \\\" \\\",\\r\\n    \\\" \\\",\\r\\n    \\\"line make_line(point a, point b) {\\\",\\r\\n    \\\"    line l = line(a.y - b.y, b.x - a.x, (a.x * b.y - a.y * b.x));\\\",\\r\\n    \\\"    return l;   \\\",\\r\\n    \\\"}\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"bool parallel(line l1, line l2) {\\\",\\r\\n    \\\"    double D = l1.a * l2.b - l2.a * l1.b;\\\",\\r\\n    \\\"    return (D == 0);\\\",\\r\\n    \\\"}\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"bool same(line l1, line l2) {\\\",\\r\\n    \\\"    double Dx = l1.c * l2.b - l2.c * l1.b;\\\",\\r\\n    \\\"    double Dy = l1.a * l2.c - l2.a * l1.c;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    return (parallel(l1, l2) && Dx == 0 && Dy == 0);\\\",\\r\\n    \\\"}\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"point intersect(line l1, line l2) {\\\",\\r\\n    \\\"    return point(-(l1.c * l2.b - l2.c * l1.b) / (l1.a * l2.b - l2.a * l1.b), -(l1.a * l2.c - l2.a * l1.c) / (l1.a * l2.b - l2.a * l1.b));\\\",\\r\\n    \\\"}\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"long double polygonArea(vector<point> p) {\\\",\\r\\n    \\\"    int sz = p.size();\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    long double area = 0;\\\",\\r\\n    \\\"    for (int i = 0; i < sz; i++)\\\",\\r\\n    \\\"        area += (p[i].x - p[(i + 1) % sz].x) * (p[i].y + p[(i + 1) % sz].y);\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    return abs(area) / 2;\\\",\\r\\n    \\\"}\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"long double ccw(point A, point B, point C) {\\\",\\r\\n    \\\"    return (B.x - A.x) * (C.y - A.y) - (B.y - A.y) * (C.x - A.x);\\\",\\r\\n    \\\"}\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"string pointInPolygon(point m, vector<point> & p) {\\\",\\r\\n    \\\"    if (ccw(p[0], p[1], p[2]) < 0)\\\",\\r\\n    \\\"        reverse(p.begin(), p.end());\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    int sz = p.size();\\\",\\r\\n    \\\"    int cnt = 0;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    for (int i = 0; i < sz; i++) {\\\",\\r\\n    \\\"        if (p[i].x <= m.x && m.x < p[(i + 1) % sz].x && ccw(p[i], p[(i + 1) % sz], m) < 0) \\\",\\r\\n    \\\"            cnt++;\\\",\\r\\n    \\\"        else \\\",\\r\\n    \\\"            if (p[(i + 1) % sz].x <= m.x && m.x < p[i].x && ccw(p[(i + 1) % sz], p[i], m) < 0)  \\\",\\r\\n    \\\"                cnt++;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        long long s = ccw(p[i], p[(i + 1) % sz], m);\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        if (s == 0) {\\\",\\r\\n    \\\"            if (m.x >= min(p[i].x, p[(i + 1) % sz].x) && m.x <= max(p[i].x, p[(i + 1) % sz].x))\\\",\\r\\n    \\\"                if (m.y >= min(p[i].y, p[(i + 1) % sz].y) && m.y <= max(p[i].y, p[(i + 1) % sz].y))\\\",\\r\\n    \\\"                    return \\\\\\\"BOUNDARY\\\\\\\";\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    return (cnt % 2 ? \\\\\\\"INSIDE\\\\\\\" : \\\\\\\"OUTSIDE\\\\\\\");\\\",\\r\\n    \\\"}\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"pair<long long, long long> pickTheorem(vector<point> & p) {\\\",\\r\\n    \\\"    int sz = p.size();\\\",\\r\\n    \\\"    long long O = 0;\\\",\\r\\n    \\\"    for (int i = 0; i < sz; i++)\\\",\\r\\n    \\\"        O += __gcd((int)abs(p[i].x - p[(i + 1) % sz].x), (int)abs(p[i].y - p[(i + 1) % sz].y));\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    long long area = 0;\\\",\\r\\n    \\\"    for (int i = 0; i < sz; i++)\\\",\\r\\n    \\\"        area += (p[i].x - p[(i + 1) % sz].x) * (p[i].y + p[(i + 1) % sz].y);\\\",\\r\\n    \\\"    long long I = (abs(area) - O) / 2 + 1;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    return make_pair(I, O);\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"}\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"// Minimum Euclidean Distance\\\",\\r\\n    \\\"inline long long distancePw2(point A, point B) {return (A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y);}\\\",\\r\\n    \\\"long long minED(int l, int r, vector<point> & p) {\\\",\\r\\n    \\\"    if (r - l + 1 <= 8) {\\\",\\r\\n    \\\"        long long minDist = distancePw2(p[l], p[r]);\\\",\\r\\n    \\\"        for (int i = l; i < r; i++)\\\",\\r\\n    \\\"            for (int j = i + 1; j <= r; j++)\\\",\\r\\n    \\\"                minDist = min(minDist, distancePw2(p[i], p[j]));\\\",\\r\\n    \\\"        return minDist;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"    int mid = (l + r) >> 1;\\\",\\r\\n    \\\"    int xmid = p[mid].x;\\\",\\r\\n    \\\"    long long minDist = min(minED(l, mid, p), minED(mid + 1, r, p));\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    sort(p.begin() + l, p.begin() + mid + 1, [&](point A, point B) {\\\",\\r\\n    \\\"        if (A.y != B.y)\\\",\\r\\n    \\\"            return A.y < B.y;\\\",\\r\\n    \\\"        \\\",\\r\\n    \\\"        return A.x < B.x;\\\",\\r\\n    \\\"    });\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    sort(p.begin() + mid + 1, p.begin() + r + 1, [&](point A, point B) {\\\",\\r\\n    \\\"        if (A.y != B.y)\\\",\\r\\n    \\\"            return A.y < B.y;\\\",\\r\\n    \\\"        \\\",\\r\\n    \\\"        return A.x < B.x;\\\",\\r\\n    \\\"    });\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"    deque<point> q;\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"    int j = mid;\\\",\\r\\n    \\\"    for (int i = l; i <= mid; i++) {\\\",\\r\\n    \\\"        while (j + 1 <= r && (p[j + 1].y < p[i].y || (p[j + 1].y - p[i].y) * (p[j + 1].y - p[i].y) <= minDist)) {\\\",\\r\\n    \\\"            j++;\\\",\\r\\n    \\\"            if ((p[j].x - xmid) * (p[j].x - xmid) <= minDist)\\\",\\r\\n    \\\"                q.push_back(p[j]);\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        while (q.size() && (q.front().y - p[i].y) * (q.front().y - p[i].y) > minDist)\\\",\\r\\n    \\\"            q.pop_front();\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"        for (point x : q)\\\",\\r\\n    \\\"            minDist = min(minDist, distancePw2(p[i], x));\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"    return minDist;\\\",\\r\\n    \\\"}\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Geometry - Geometry\\\"\\r\\n}\\r\\n}\",\"Graph.code-snippets\":\"{\\r\\n\\\"Gen - Graph\\\": {\\r\\n  \\\"prefix\\\": \\\"Gen - Graph\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"//n ^ 2 * log\\\",\\r\\n    \\\"void Graph(int n, int maxW) {\\\",\\r\\n    \\\"    n = Rand(1, n);\\\",\\r\\n    \\\"    maxW = Rand(1, maxW);\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    DSU.init(n);\\\",\\r\\n    \\\"    vector<pair<int, int>> edge;\\\",\\r\\n    \\\"    for (int i = 1; i < n; i++)\\\",\\r\\n    \\\"        for (int j = i + 1; j <= n; j++)\\\",\\r\\n    \\\"            if (Rand(1, 2) == 1)\\\",\\r\\n    \\\"                edge.push_back(make_pair(i, j));\\\",\\r\\n    \\\"            else\\\",\\r\\n    \\\"                edge.push_back(make_pair(j, i));\\\",\\r\\n    \\\"    \\\",\\r\\n    \\\"    random_shuffle(edge.begin(), edge.end());\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    int posR = 0;\\\",\\r\\n    \\\"    for (int i = 0; i < edge.size(); i++)\\\",\\r\\n    \\\"        if (DSU.join(edge[i].first, edge[i].second))\\\",\\r\\n    \\\"            posR = i + 1;\\\",\\r\\n    \\\"    \\\",\\r\\n    \\\"    while (edge.size() > posR)\\\",\\r\\n    \\\"        edge.pop_back();\\\",\\r\\n    \\\"    \\\",\\r\\n    \\\"    cout << n << ' ' << edge.size() << '\\\\\\\\n';\\\",\\r\\n    \\\"    for (pair<int, int> x : edge) {\\\",\\r\\n    \\\"        cout << x.first << ' ' << x.second << ' ';\\\",\\r\\n    \\\"        // cout << Rand(1, maxW);\\\",\\r\\n    \\\"        cout << '\\\\\\\\n';\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"}\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Gen - Graph\\\"\\r\\n}\\r\\n}\",\"Hash.code-snippets\":\"{\\r\\n\\\"String - Hash\\\": {\\r\\n  \\\"prefix\\\": \\\"String - Hash\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"const long long base = 311;\\\",\\r\\n    \\\"const long long mxSize = 1e6 + 100;\\\",\\r\\n    \\\"const long long modHash[4] = {(int)1e9 + 2277, (int)1e9 + 5277, (int)1e9 + 8277, (int)1e9 + 9277};\\\",\\r\\n    \\\"const long long nMod = 2;\\\",\\r\\n    \\\"long long pw[mxSize][nMod];\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"void precalcHash(int sz, int szMod) {\\\",\\r\\n    \\\"    for (int i = 0; i < szMod; i++)\\\",\\r\\n    \\\"        pw[0][i] = 1;\\\",\\r\\n    \\\"    for (int i = 1; i < sz; i++)\\\",\\r\\n    \\\"        for (int j = 0; j < szMod; j++)\\\",\\r\\n    \\\"            (pw[i][j] = pw[i - 1][j] * base) %= modHash[j];\\\",\\r\\n    \\\"}\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"struct HashString {\\\",\\r\\n    \\\"    vector<vector<long long>> hashVal;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    void buildHash(string s) {\\\",\\r\\n    \\\"        int n = s.size();\\\",\\r\\n    \\\"        hashVal.resize(n + 1);\\\",\\r\\n    \\\"        for (int i = 0; i <= n; i++)\\\",\\r\\n    \\\"            hashVal[i].resize(nMod);\\\",\\r\\n    \\\"        for (int i = 1; i <= n; i++) {\\\",\\r\\n    \\\"            for (int j = 0; j < nMod; j++)\\\",\\r\\n    \\\"                (hashVal[i][j] = hashVal[i - 1][j] * base + int(s[i - 1])) %= modHash[j];\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    long long getHash(int l, int r, int pos) {\\\",\\r\\n    \\\"        return (hashVal[r][pos] - hashVal[l - 1][pos] * pw[r - l + 1][pos] + modHash[pos] * modHash[pos]) % modHash[pos];\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"};\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"String - Hash\\\"\\r\\n}\\r\\n}\",\"HeavyLightDecomposition.code-snippets\":\"{\\r\\n\\\"Graph - HeavyLightDecomposition\\\": {\\r\\n  \\\"prefix\\\": \\\"Graph - HLD\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"struct HeavyLightDecomposition {\\\",\\r\\n    \\\"    int Sz[N], Par[N], Pos[N], H[N], ChainID[N], ChainHead[N];\\\",\\r\\n    \\\"    int CurPos, CurChain;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    void dfs(int u, int par) {\\\",\\r\\n    \\\"        Par[u] = par, H[u] = H[par] + 1;\\\",\\r\\n    \\\"        for (int x : edge[u]) {\\\",\\r\\n    \\\"            if (x == par)\\\",\\r\\n    \\\"                continue;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"            dfs(x, u);\\\",\\r\\n    \\\"            Sz[u] += Sz[x];\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        Sz[u]++;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    void hld(int u, int par) {\\\",\\r\\n    \\\"        if (!ChainHead[CurChain])\\\",\\r\\n    \\\"            ChainHead[CurChain] = u;\\\",\\r\\n    \\\"            \\\",\\r\\n    \\\"        Pos[u] = ++CurPos, ChainID[u] = CurChain;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        int BigChild = -1;\\\",\\r\\n    \\\"        for (int x : edge[u]) {\\\",\\r\\n    \\\"            if (x == par)\\\",\\r\\n    \\\"                continue;\\\",\\r\\n    \\\"            \\\",\\r\\n    \\\"            if (BigChild == -1 || Sz[x] > Sz[BigChild])\\\",\\r\\n    \\\"                BigChild = x;\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        if (BigChild != -1)\\\",\\r\\n    \\\"            hld(BigChild, u);\\\",\\r\\n    \\\"        \\\",\\r\\n    \\\"        for (int x : edge[u]) {\\\",\\r\\n    \\\"            if (x == par || x == BigChild)\\\",\\r\\n    \\\"                continue;\\\",\\r\\n    \\\"            \\\",\\r\\n    \\\"            CurChain++;\\\",\\r\\n    \\\"            hld(x, u);\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    void update(int u, int v) {\\\",\\r\\n    \\\"        while (ChainID[u] != ChainID[v]) {\\\",\\r\\n    \\\"            if (H[Par[ChainHead[ChainID[u]]]] < H[Par[ChainHead[ChainID[v]]]])\\\",\\r\\n    \\\"                swap(u, v);\\\",\\r\\n    \\\"            \\\",\\r\\n    \\\"            //update:Pos[ChainHead[ChainID[u]]] -> Pos[u]\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"            u = Par[ChainHead[ChainID[u]]];\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        if (Pos[u] > Pos[v])\\\",\\r\\n    \\\"            swap(u, v);\\\",\\r\\n    \\\"        \\\",\\r\\n    \\\"        //update:Pos[u] -> Pos[v];\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    int get(int u, int v) {\\\",\\r\\n    \\\"        int res = 0;\\\",\\r\\n    \\\"        while (ChainID[u] != ChainID[v]) {\\\",\\r\\n    \\\"            if (H[Par[ChainHead[ChainID[u]]]] < H[Par[ChainHead[ChainID[v]]]])\\\",\\r\\n    \\\"                swap(u, v);\\\",\\r\\n    \\\"            \\\",\\r\\n    \\\"            //get:Pos[ChainHead[ChainID[u]]] -> Pos[u]\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"            u = Par[ChainHead[ChainID[u]]];\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        if (Pos[u] > Pos[v])\\\",\\r\\n    \\\"            swap(u, v);\\\",\\r\\n    \\\"        \\\",\\r\\n    \\\"        //get:Pos[u] -> Pos[v];\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        return res;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    void prepare(int root) {\\\",\\r\\n    \\\"        dfs(root, 0);       \\\",\\r\\n    \\\"        hld(root, 0); \\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"} HLD;\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Graph - HeavyLightDecomposition\\\"\\r\\n}\\r\\n}\",\"HopcoftKarp.code-snippets\":\"{\\r\\n\\\"Graph - HopcoftKarp\\\": {\\r\\n  \\\"prefix\\\": \\\"Graph - HopcoftKarp\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"struct MaximumMatching {\\\",\\r\\n    \\\"    vector<int> x, y, cnt, q;\\\",\\r\\n    \\\"    vector<vector<int>> edge;\\\",\\r\\n    \\\"    int n;\\\",\\r\\n    \\\"    int inf;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    MaximumMatching(int _n) {\\\",\\r\\n    \\\"        n = _n, inf = 1e9 + 999;\\\",\\r\\n    \\\"        x = y = cnt = q = vector<int>(n + 1, 0);\\\",\\r\\n    \\\"        edge = vector<vector<int>>(n + 1);        \\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    void addEdge(int u, int v) {edge[u].push_back(v);}\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    bool findpath() {\\\",\\r\\n    \\\"        int l = 1;\\\",\\r\\n    \\\"        int r = 0;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        for (int u = 1; u <= n; ++u)\\\",\\r\\n    \\\"            if (!x[u]) {\\\",\\r\\n    \\\"                cnt[u] = 0;\\\",\\r\\n    \\\"                q[++r] = u;\\\",\\r\\n    \\\"            } else \\\",\\r\\n    \\\"                cnt[u] = inf;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        cnt[0] = inf;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        while (l <= r) {\\\",\\r\\n    \\\"            int u = q[l++];\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"            for (int v : edge[u])\\\",\\r\\n    \\\"                if (cnt[y[v]] == inf) {\\\",\\r\\n    \\\"                    cnt[y[v]] = cnt[u] + 1;\\\",\\r\\n    \\\"                    if (y[v]) q[++r] = y[v];\\\",\\r\\n    \\\"                } \\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        return cnt[0] != inf;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    bool dfs(int u) {\\\",\\r\\n    \\\"        for (int v : edge[u]) {\\\",\\r\\n    \\\"            if (y[v] == 0)  {\\\",\\r\\n    \\\"                x[u] = v, y[v] = u, cnt[u] = inf;\\\",\\r\\n    \\\"                return 1;\\\",\\r\\n    \\\"            }\\\",\\r\\n    \\\"                \\\",\\r\\n    \\\"            if (cnt[y[v]] == cnt[u] + 1)\\\",\\r\\n    \\\"                if (dfs(y[v])) {\\\",\\r\\n    \\\"                    x[u] = v, y[v] = u, cnt[u] = inf;\\\",\\r\\n    \\\"                    return 1;\\\",\\r\\n    \\\"                }\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        cnt[u] = inf;\\\",\\r\\n    \\\"        return 0;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    void match() {\\\",\\r\\n    \\\"        int res = 0;\\\",\\r\\n    \\\"        while(findpath()) {\\\",\\r\\n    \\\"            for (int u = 1; u <= n; ++u) \\\",\\r\\n    \\\"                if (!x[u] && dfs(u)) ++res;\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        cout << res << '\\\\\\\\n';\\\",\\r\\n    \\\"        // for (int i = 1; i <= n; i++)\\\",\\r\\n    \\\"        //     if (x[i])\\\",\\r\\n    \\\"        //         cout << i << ' ' << x[i] << '\\\\\\\\n';\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"};\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Graph - HopcoftKarp\\\"\\r\\n}\\r\\n}\",\"Hungari.code-snippets\":\"{\\r\\n\\\"Graph - Hungari\\\": {\\r\\n  \\\"prefix\\\": \\\"Graph - Hungari\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"struct MaximumMaching {\\\",\\r\\n    \\\"    int c[N][N], fx[N], fy[N], trace[N], link[N], dmin[N], matchX[N], matchY[N];\\\",\\r\\n    \\\"    queue<int> st;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    int n;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    void init(int _n) {\\\",\\r\\n    \\\"        n = _n;\\\",\\r\\n    \\\"        for (int i = 1; i <= n; i++)\\\",\\r\\n    \\\"            for (int j = 1; j <= n; j++)\\\",\\r\\n    \\\"                c[i][j] = INF;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        for (int i = 1; i <= n; i++) {\\\",\\r\\n    \\\"            fx[i] = fy[i] = INF;\\\",\\r\\n    \\\"            matchX[i] = matchY[i] = 0;\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    void addEdge(int u, int v, int w) {minimize(c[u][v], w);}\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    int getC(int i, int j) {\\\",\\r\\n    \\\"        return c[i][j] - fx[i] - fy[j];\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    int findPath() {\\\",\\r\\n    \\\"        while (! st.empty()) {\\\",\\r\\n    \\\"            int i = st.front();\\\",\\r\\n    \\\"            st.pop();\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"            for (int j = 1; j <= n; j++) {\\\",\\r\\n    \\\"                if (trace[j]) continue;\\\",\\r\\n    \\\"                int w = getC(i,j);\\\",\\r\\n    \\\"                \\\",\\r\\n    \\\"                if (w == 0) {\\\",\\r\\n    \\\"                    trace[j] = i;\\\",\\r\\n    \\\"                    if (matchY[j] == 0) return j;\\\",\\r\\n    \\\"                    st.push(matchY[j]);\\\",\\r\\n    \\\"                }\\\",\\r\\n    \\\"                \\\",\\r\\n    \\\"                if (dmin[j] > w) {\\\",\\r\\n    \\\"                    dmin[j] = w;\\\",\\r\\n    \\\"                    link[j] = i;\\\",\\r\\n    \\\"                }\\\",\\r\\n    \\\"            }\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"        \\\",\\r\\n    \\\"        return -1;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    int Rotate(int s) {\\\",\\r\\n    \\\"        int del = INF;\\\",\\r\\n    \\\"        for (int j = 1; j <= n; j++)\\\",\\r\\n    \\\"            if (trace[j] == 0) \\\",\\r\\n    \\\"                del = min(del, dmin[j]);\\\",\\r\\n    \\\"       \\\",\\r\\n    \\\"        fx[s] += del;\\\",\\r\\n    \\\"        for (int j = 1; j <= n; j++)\\\",\\r\\n    \\\"            if (trace[j]) {\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"                int i = matchY[j];\\\",\\r\\n    \\\"                fx[i] += del;\\\",\\r\\n    \\\"                fy[j] -= del;\\\",\\r\\n    \\\"            } else\\\",\\r\\n    \\\"                dmin[j] -= del;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        for (int j = 1; j <= n; j++)\\\",\\r\\n    \\\"            if (trace[j] == 0 && dmin[j] == 0) {\\\",\\r\\n    \\\"                trace[j] = link[j];\\\",\\r\\n    \\\"                if (matchY[j] == 0) return j;\\\",\\r\\n    \\\"                st.push(matchY[j]);\\\",\\r\\n    \\\"            }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        return -1;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    void solve(int s) {\\\",\\r\\n    \\\"        for (int j = 1; j <= n; j++) {\\\",\\r\\n    \\\"            trace[j] = 0;\\\",\\r\\n    \\\"            dmin[j] = getC(s,j);\\\",\\r\\n    \\\"            link[j] = s;\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        st = queue<int>();\\\",\\r\\n    \\\"        st.push(s);\\\",\\r\\n    \\\"        int t = -1, k;\\\",\\r\\n    \\\"        while (t == -1) {\\\",\\r\\n    \\\"            t = findPath();\\\",\\r\\n    \\\"            if (t == -1) t = Rotate(s);\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        while (t != 0) {\\\",\\r\\n    \\\"            s = trace[t];\\\",\\r\\n    \\\"            k = matchX[s];\\\",\\r\\n    \\\"            matchX[s] = t;\\\",\\r\\n    \\\"            matchY[t] = s;\\\",\\r\\n    \\\"            t = k;\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    int match() {\\\",\\r\\n    \\\"        for (int i = 1; i <= n; i++)\\\",\\r\\n    \\\"            for (int j = 1; j <= n; j++)\\\",\\r\\n    \\\"                minimize(fx[i], c[i][j]);\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        for (int j = 1; j <= n; j++)\\\",\\r\\n    \\\"            for (int i = 1; i <= n; i++)\\\",\\r\\n    \\\"                minimize(fy[i], c[i][j] - fx[i]);\\\",\\r\\n    \\\"        \\\",\\r\\n    \\\"        for (int i = 1; i <= n; i++)\\\",\\r\\n    \\\"            solve(i);\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        int res = 0;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        for (int i = 1; i <= n; i++)\\\",\\r\\n    \\\"            if (c[i][matchX[i]] < INF)\\\",\\r\\n    \\\"                res += c[i][matchX[i]];\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        // for (int i = 1; i <= n; i++)\\\",\\r\\n    \\\"        //     if (matchX[i])\\\",\\r\\n    \\\"        //         cout << i << ' ' << matchX[i] << '\\\\\\\\n';\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        return res;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"} match;\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Graph - Hungari\\\"\\r\\n}\\r\\n}\",\"Intersect.code-snippets\":\"{\\n\\\"Geometry - Intersect\\\": {\\n  \\\"prefix\\\": \\\"Geometry - Intersect\\\",\\n  \\\"body\\\": [\\n    \\\"point intersect(line l1, line l2) {\\\",\\n    \\\"    return point(-(l1.c * l2.b - l2.c * l1.b) / (l1.a * l2.b - l2.a * l1.b), -(l1.a * l2.c - l2.a * l1.c) / (l1.a * l2.b - l2.a * l1.b));\\\",\\n    \\\"}\\\"\\n  ],\\n  \\\"description\\\": \\\"Geometry - Intersect\\\"\\n}\\n}\",\"IsPrime.code-snippets\":\"{\\r\\n\\\"Math - IsPrime\\\": {\\r\\n  \\\"prefix\\\": \\\"Math - IsPrime\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"bool isPrime(long long n) {\\\",\\r\\n    \\\"    if (n == 2 || n == 3)\\\",\\r\\n    \\\"        return true;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    if (n <= 1 || n % 2 == 0 || n % 3 == 0)\\\",\\r\\n    \\\"        return false;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    for (long long i = 5; i <= sqrt(n); i += 6)\\\",\\r\\n    \\\"        if (n % i == 0 || n % (i + 2) == 0)\\\",\\r\\n    \\\"            return false;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    return true;\\\",\\r\\n    \\\"}\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Math - IsPrime\\\"\\r\\n}\\r\\n}\",\"JointAndBridge.code-snippets\":\"{\\r\\n\\\"Graph - JointAndBridge\\\": {\\r\\n  \\\"prefix\\\": \\\"Graph - JointAndBridge\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"int timeDfs, bridge;\\\",\\r\\n    \\\"int low[N], num[N];\\\",\\r\\n    \\\"bool joint[N];\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"void dfs(int u, int par) {\\\",\\r\\n    \\\"    int child = 0;\\\",\\r\\n    \\\"    num[u] = low[u] = ++timeDfs;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    for (int x : edge[u]) {\\\",\\r\\n    \\\"        if (x == par)\\\",\\r\\n    \\\"            continue;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        if (!num[x]) {\\\",\\r\\n    \\\"            dfs(x, u);\\\",\\r\\n    \\\"            child++;\\\",\\r\\n    \\\"            low[u] = min(low[u], low[x]);\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"            if (low[x] == num[x])\\\",\\r\\n    \\\"                bridge++;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"            if (u == par) {\\\",\\r\\n    \\\"                if (child > 1)\\\",\\r\\n    \\\"                    joint[u] = true;\\\",\\r\\n    \\\"            } else if (low[x] >= num[u])\\\",\\r\\n    \\\"                joint[u] = true;\\\",\\r\\n    \\\"        } else\\\",\\r\\n    \\\"            low[u] = min(low[u], num[x]);\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"}\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Graph - JointAndBridge\\\"\\r\\n}\\r\\n}\",\"KMPfunction.code-snippets\":\"{\\r\\n\\\"String - KMP\\\": {\\r\\n  \\\"prefix\\\": \\\"String - KMP\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"vector<int> KMPfunction(string s) {\\\",\\r\\n    \\\"    int n = s.size();\\\",\\r\\n    \\\"    vector<int> pi(n, 0);\\\",\\r\\n    \\\"    for (int i = 1; i < n; i++) {\\\",\\r\\n    \\\"        int j = pi[i - 1];\\\",\\r\\n    \\\"        \\\",\\r\\n    \\\"        while (j > 0 && s[i] != s[j])\\\",\\r\\n    \\\"            j = pi[j - 1];\\\",\\r\\n    \\\"        \\\",\\r\\n    \\\"        if (s[i] == s[j])\\\",\\r\\n    \\\"            j++;\\\",\\r\\n    \\\"        \\\",\\r\\n    \\\"        pi[i] = j;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    return pi;\\\",\\r\\n    \\\"}\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"String - KMP\\\"\\r\\n}\\r\\n}\",\"LichaoTree.code-snippets\":\"{\\r\\n\\\"Data Structures - LichaoTree\\\": {\\r\\n  \\\"prefix\\\": \\\"Data Structures - LichaoTree\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"struct line {\\\",\\r\\n    \\\"    int a, b;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    line() : a(0), b(1e9) {};\\\",\\r\\n    \\\"    line(int a, int b) : a(a), b(b) {};\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    int operator() (int x) {\\\",\\r\\n    \\\"        return a * x + b;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"};\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"const int mxLine = 1e6;\\\",\\r\\n    \\\"line S[4 * mxLine + 10];\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"struct LiChaoTree {\\\",\\r\\n    \\\"    void addLine(int id, int l, int r, line New) {\\\",\\r\\n    \\\"        if (l == r) {\\\",\\r\\n    \\\"            if (S[id](l) > New(l))\\\",\\r\\n    \\\"                swap(S[id], New);\\\",\\r\\n    \\\"            \\\",\\r\\n    \\\"            return;\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        int mid = l + r >> 1;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        if (S[id].a > New.a)\\\",\\r\\n    \\\"            swap(S[id], New);\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        if (S[id](mid) > New(mid)) {\\\",\\r\\n    \\\"            swap(S[id], New);\\\",\\r\\n    \\\"            addLine(id << 1 | 1, mid + 1, r, New);\\\",\\r\\n    \\\"        } else \\\",\\r\\n    \\\"            addLine(id << 1, l, mid, New);\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    int getQuery(int id, int l, int r, int x) {\\\",\\r\\n    \\\"        if (x < l || x > r)\\\",\\r\\n    \\\"            return 1e9;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        if (l == r)\\\",\\r\\n    \\\"            return S[id](x);\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        int mid = l + r >> 1;\\\",\\r\\n    \\\"        if (x <= mid)\\\",\\r\\n    \\\"            return min(S[id](x), getQuery(id << 1, l, mid, x));\\\",\\r\\n    \\\"        else\\\",\\r\\n    \\\"            return min(S[id](x), getQuery(id << 1 | 1, mid + 1, r, x));\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"} LiChao;\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Data Structures - LichaoTree\\\"\\r\\n}\\r\\n}\",\"Line.code-snippets\":\"{\\n\\\"Geometry - Line\\\": {\\n  \\\"prefix\\\": \\\"Geometry - Line\\\",\\n  \\\"body\\\": [\\n    \\\"struct line {\\\",\\n    \\\"    double a, b, c;\\\",\\n    \\\"    line() : a(0), b(0), c(0) {};\\\",\\n    \\\"    line(double a, double b, double c) : a(a), b(b), c(c) {};\\\",\\n    \\\"};\\\"\\n  ],\\n  \\\"description\\\": \\\"Geometry - Line\\\"\\n}\\n}\",\"LowestCommonAncestor(Query O(1)).code-snippets\":\"{\\r\\n\\\"Graph - LCA(Query O(1))\\\": {\\r\\n  \\\"prefix\\\": \\\"Graph - LCA(Query O(1))\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"pair<int, int> sp[2 * N][LOG];\\\",\\r\\n    \\\"struct LowestCommonAncestor {\\\",\\r\\n    \\\"    int h[N], p[N], cntEuler;\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"    void dfs(int u, int par) {\\\",\\r\\n    \\\"        h[u] = h[par] + 1, sp[++cntEuler][0] = make_pair(h[u], u), p[u] = cntEuler;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        for (int x : edge[u])\\\",\\r\\n    \\\"            if (x != par) {\\\",\\r\\n    \\\"                dfs(x, u);\\\",\\r\\n    \\\"                sp[++cntEuler][0] = make_pair(h[u], u);\\\",\\r\\n    \\\"            }\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"    void prepare(int root) {\\\",\\r\\n    \\\"        dfs(root, 0);      \\\",\\r\\n    \\\"        for (int j = 1; j < LOG; j++)   \\\",\\r\\n    \\\"            for (int i = 1; i <= cntEuler; i++)\\\",\\r\\n    \\\"                if (i + (1 << (j - 1)) <= cntEuler)\\\",\\r\\n    \\\"                    sp[i][j] = min(sp[i][j - 1], sp[i + (1 << (j - 1))][j - 1]);\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"    int lca(int u, int v) {\\\",\\r\\n    \\\"        if (u == v)\\\",\\r\\n    \\\"            return u;\\\",\\r\\n    \\\"            \\\",\\r\\n    \\\"        int L = min(p[u], p[v]), R = max(p[u], p[v]);\\\",\\r\\n    \\\"        int lb = (R - L == 0 ? 0 : log2(R - L));\\\",\\r\\n    \\\"        \\\",\\r\\n    \\\"        return min(sp[L][lb], sp[R - (1 << lb) + 1][lb]).se;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"} LCA;\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Graph - LCA(Query O(1))\\\"\\r\\n}\\r\\n}\",\"LowestCommonAncestor.code-snippets\":\"{\\r\\n\\\"Graph - LCA\\\": {\\r\\n  \\\"prefix\\\": \\\"Graph - LCA\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"const int LOGN = 19;\\\",\\r\\n    \\\"int Par[N][LOGN], h[N];\\\",\\r\\n    \\\"struct LowestCommonAncestor {\\\",\\r\\n    \\\"    void dfs(int u, int par) {\\\",\\r\\n    \\\"        Par[u][0] = par;\\\",\\r\\n    \\\"        h[u] = h[par] + 1;\\\",\\r\\n    \\\"        for (int x : edge[u])\\\",\\r\\n    \\\"            if (par != x)\\\",\\r\\n    \\\"                dfs(x, u);\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    void prepare(int root) {\\\",\\r\\n    \\\"        dfs(root, root);\\\",\\r\\n    \\\"        for (int j = 1; j < LOGN; j++)\\\",\\r\\n    \\\"            for (int i = 1; i <= n; i++)\\\",\\r\\n    \\\"                Par[i][j] = Par[Par[i][j - 1]][j - 1];\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    int lca(int u, int v) {\\\",\\r\\n    \\\"        if (h[u] > h[v])\\\",\\r\\n    \\\"            swap(u, v);\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        for (int j = LOGN - 1; j >= 0; j--)\\\",\\r\\n    \\\"            if ((h[v] - (1 << j)) >= h[u])\\\",\\r\\n    \\\"                v = Par[v][j];\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        if (u == v)\\\",\\r\\n    \\\"            return u;\\\",\\r\\n    \\\"        for (int j = LOGN - 1; j >= 0; j--)\\\",\\r\\n    \\\"            if (Par[u][j] != Par[v][j]) {\\\",\\r\\n    \\\"                u = Par[u][j];\\\",\\r\\n    \\\"                v = Par[v][j];\\\",\\r\\n    \\\"            }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        return Par[u][0];\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    int dist(int u, int v) {\\\",\\r\\n    \\\"        return h[u] + h[v] - 2 * h[lca(u, v)];\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    int jump(int u, int dist) {\\\",\\r\\n    \\\"        for (int i = LOGN - 1; i >= 0; i--)\\\",\\r\\n    \\\"            if (dist >= (1 << i)) {\\\",\\r\\n    \\\"                u = Par[u][i];\\\",\\r\\n    \\\"                dist -= (1 << i);\\\",\\r\\n    \\\"            }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        return u;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"} LCA;\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Graph - LCA\\\"\\r\\n}\\r\\n}\",\"Makeline.code-snippets\":\"{\\n\\\"Geometry - Makeline\\\": {\\n  \\\"prefix\\\": \\\"Geometry - Makeline\\\",\\n  \\\"body\\\": [\\n    \\\"line make_line(point a, point b) {\\\",\\n    \\\"    return line(a.y - b.y, b.x - a.x, (a.x * b.y - a.y * b.x));   \\\",\\n    \\\"}\\\"\\n  ],\\n  \\\"description\\\": \\\"Geometry - Makeline\\\"\\n}\\n}\",\"Manacher.code-snippets\":\"{\\r\\n\\\"String - Manacher\\\": {\\r\\n  \\\"prefix\\\": \\\"String - Manacher\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"int manacher(string s){\\\",\\r\\n    \\\"    string t = \\\\\\\" \\\\\\\";\\\",\\r\\n    \\\"    for (int i = 0; i < s.size(); i++) {\\\",\\r\\n    \\\"        t.push_back(s[i]);\\\",\\r\\n    \\\"        t.push_back(' ');\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"    int n = t.size();\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    vector<int> a(n, 0);\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    a[0] = 1;\\\",\\r\\n    \\\"    int c = 1, r = 1, res = 0;\\\",\\r\\n    \\\"    for (int i = 1; i < n; i++){\\\",\\r\\n    \\\"        int iu = 2 * c - i;\\\",\\r\\n    \\\"        a[i] = (iu > 0 && r > i ? min(r - i, a[iu]) : 0);\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        while (i - a[i] - 1 >= 0 && i + a[i] + 1 < n && t[i - a[i] - 1] == t[i + a[i] + 1]) \\\",\\r\\n    \\\"            a[i]++;\\\",\\r\\n    \\\"        \\\",\\r\\n    \\\"        if (i + a[i] > r){\\\",\\r\\n    \\\"            c = i;\\\",\\r\\n    \\\"            r = i + a[i];\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        res = max(res, a[i]);\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    return res;\\\",\\r\\n    \\\"}\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"String - Manacher\\\"\\r\\n}\\r\\n}\",\"MatrixMultiplication.code-snippets\":\"{\\r\\n\\\"Math - Matrix Multiplication\\\": {\\r\\n  \\\"prefix\\\": \\\"Math - Matrix Multiplication\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"template <int mod = 1000000007>\\\",\\r\\n    \\\"struct Matrix {\\\",\\r\\n    \\\"    vector<vector<int>> value;\\\",\\r\\n    \\\"    Matrix(int n, int m) : value(vector<vector<int>>(n, vector<int>(m, 0))) {};\\\",\\r\\n    \\\"    Matrix(vector<vector<int>> value) : value(value) {};\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    Matrix operator* (const Matrix &b) {\\\",\\r\\n    \\\"        int n = (int)value.size(), m = (int)value[0].size(), p = (int)b.value[0].size();\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        Matrix c(n, p);\\\",\\r\\n    \\\"        for (int i = 0; i < n; i++)\\\",\\r\\n    \\\"            for (int j = 0; j < p; j++)\\\",\\r\\n    \\\"                for (int k = 0; k < m; k++)\\\",\\r\\n    \\\"                    (c.value[i][j] += 1ll * value[i][k] * b.value[k][j] % mod) %= mod;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        return c;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    Matrix operator^ (long long k) {\\\",\\r\\n    \\\"        Matrix p((int)value.size(), (int)value.size());\\\",\\r\\n    \\\"        for (int i = 0; i < (int)p.value.size(); i++)\\\",\\r\\n    \\\"            p.value[i][i] = 1;\\\",\\r\\n    \\\"        \\\",\\r\\n    \\\"        Matrix a(*this);\\\",\\r\\n    \\\"        while (k) {\\\",\\r\\n    \\\"            if (k & 1)\\\",\\r\\n    \\\"                p = p * a;\\\",\\r\\n    \\\"            \\\",\\r\\n    \\\"            k >>= 1, a = a * a;\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        return p;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"};\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Math - Matrix Multiplication\\\"\\r\\n}\\r\\n}\",\"MaximumFlow.code-snippets\":\"{\\r\\n\\\"Graph - MaximumFlow\\\": {\\r\\n  \\\"prefix\\\": \\\"Graph - MaximumFlow\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"struct MaximumFlow {\\\",\\r\\n    \\\"    vector<int> idEdge[N];\\\",\\r\\n    \\\"    int trace[N];\\\",\\r\\n    \\\"    int s, t;\\\",\\r\\n    \\\"    int maxFlow;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    struct flowEdge {\\\",\\r\\n    \\\"        int u, v, flow;\\\",\\r\\n    \\\"    };\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    vector<flowEdge> edge;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    MaximumFlow () {\\\",\\r\\n    \\\"        maxFlow = 0;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"    void updateSourceSink(int source, int sink) {\\\",\\r\\n    \\\"        s = source;\\\",\\r\\n    \\\"        t = sink;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"    void addEdge(int u, int v, int c) {\\\",\\r\\n    \\\"        flowEdge Edge;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        Edge = {u, v, c};\\\",\\r\\n    \\\"        edge.push_back(Edge);\\\",\\r\\n    \\\"        idEdge[u].push_back(edge.size() - 1);\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        Edge = {v, u, 0};\\\",\\r\\n    \\\"        edge.push_back(Edge);\\\",\\r\\n    \\\"        idEdge[v].push_back(edge.size() - 1);\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"    void bfs(int u) {\\\",\\r\\n    \\\"        queue<int> q;\\\",\\r\\n    \\\"        q.push(u);\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        while (!q.empty()) {\\\",\\r\\n    \\\"            int u = q.front();\\\",\\r\\n    \\\"            q.pop();\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"            for (int x : idEdge[u])\\\",\\r\\n    \\\"                if (trace[edge[x].v] == -1 && edge[x].flow) {\\\",\\r\\n    \\\"                    trace[edge[x].v] = x;\\\",\\r\\n    \\\"                    q.push(edge[x].v);\\\",\\r\\n    \\\"                }\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"    bool increaseFlow() {\\\",\\r\\n    \\\"        for (int i = 1; i <= n; i++)\\\",\\r\\n    \\\"            trace[i] = -1;\\\",\\r\\n    \\\"        trace[s] = 0;\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"        bfs(s);\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        if (trace[t] == -1)\\\",\\r\\n    \\\"            return false;\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"        vector<int> v;\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"        int increase = 1e9 + 999;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        int sink = t;\\\",\\r\\n    \\\"        while (sink != s) {\\\",\\r\\n    \\\"            minimize(increase, edge[trace[sink]].flow);\\\",\\r\\n    \\\"            v.push_back(trace[sink]);\\\",\\r\\n    \\\"            sink = edge[trace[sink]].u;\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        for (int x : v) {\\\",\\r\\n    \\\"            edge[x].flow -= increase;\\\",\\r\\n    \\\"            edge[x ^ 1].flow += increase;\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"        maxFlow += increase;\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"        return increase;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"    int Maching() {\\\",\\r\\n    \\\"        do {\\\",\\r\\n    \\\"            if (!increaseFlow()) \\\",\\r\\n    \\\"                break;\\\",\\r\\n    \\\"        } while (true);\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"        return maxFlow;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"} flow;\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Graph - MaximumFlow\\\"\\r\\n}\\r\\n}\",\"MillerRabin.code-snippets\":\"{\\r\\n\\\"Math - MillerRabin\\\": {\\r\\n  \\\"prefix\\\": \\\"Math - MillerRabin\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"struct MillerRabin {\\\",\\r\\n    \\\"    pair<long long, long long> factor(long long n) {\\\",\\r\\n    \\\"        long long s = 0;\\\",\\r\\n    \\\"        while ((n & 1) == 0)\\\",\\r\\n    \\\"            s++, n >>= 1;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        return make_pair(s, n);\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    long long pow(long long a, long long d, long long n) {\\\",\\r\\n    \\\"        a = a % n;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        long long res = 1;\\\",\\r\\n    \\\"        while (d > 0) {\\\",\\r\\n    \\\"            if (d & 1)\\\",\\r\\n    \\\"                res = res * a % n;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"            d >>= 1, a = a * a % n;\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        return res;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    bool checkA(long long s, long long d, long long n, long long a) {\\\",\\r\\n    \\\"        if (n == a)\\\",\\r\\n    \\\"            return true;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        long long p = pow(a, d, n);\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        if (p == 1)\\\",\\r\\n    \\\"            return true;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        for (; s > 0; s--) {\\\",\\r\\n    \\\"            if (p == n - 1)\\\",\\r\\n    \\\"                return true;\\\",\\r\\n    \\\"                \\\",\\r\\n    \\\"            p = p * p % n;  \\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        return false;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    bool isPrime(long long n) {\\\",\\r\\n    \\\"        if (n < 2)\\\",\\r\\n    \\\"            return false;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        if ((n & 1) == 0)\\\",\\r\\n    \\\"            return (n == 2);\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        long long s, d;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        tie(s, d) = factor(n - 1);\\\",\\r\\n    \\\"        return (checkA(s, d, n, 2) && checkA(s, d, n, 3));\\\",\\r\\n    \\\"        // 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"} Miller;\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Math - MillerRabin\\\"\\r\\n}\\r\\n}\",\"MinCut.code-snippets\":\"{\\n\\\"Graph - MinCut\\\": {\\n  \\\"prefix\\\": \\\"Graph - MinCut\\\",\\n  \\\"body\\\": [\\n    \\\"struct maximumFlow {\\\",\\n    \\\" \\\",\\n    \\\"    vector<int> idEdge[N];\\\",\\n    \\\"    int trace[N];\\\",\\n    \\\"    int s, t;\\\",\\n    \\\"    int maximumflow;\\\",\\n    \\\"    bool visited[N];\\\",\\n    \\\" \\\",\\n    \\\"    struct flowEdge {\\\",\\n    \\\" \\\",\\n    \\\"        int u, v, flow;\\\",\\n    \\\" \\\",\\n    \\\"    };\\\",\\n    \\\" \\\",\\n    \\\"    vector<flowEdge> edge;\\\",\\n    \\\" \\\",\\n    \\\"    maximumFlow () {\\\",\\n    \\\" \\\",\\n    \\\"        maximumflow = 0;\\\",\\n    \\\" \\\",\\n    \\\"    }\\\",\\n    \\\" \\\",\\n    \\\"    void updateSourceSink(int source, int sink) {\\\",\\n    \\\" \\\",\\n    \\\"        s = source;\\\",\\n    \\\"        t = sink;\\\",\\n    \\\" \\\",\\n    \\\"    }\\\",\\n    \\\" \\\",\\n    \\\"    void addEdge(int u, int v) {\\\",\\n    \\\" \\\",\\n    \\\"        flowEdge Edge;\\\",\\n    \\\" \\\",\\n    \\\"        Edge = {u, v, 1};\\\",\\n    \\\"        edge.push_back(Edge);\\\",\\n    \\\"        idEdge[u].push_back(edge.size() - 1);\\\",\\n    \\\" \\\",\\n    \\\"        Edge = {v, u, 1};\\\",\\n    \\\"        edge.push_back(Edge);\\\",\\n    \\\"        idEdge[v].push_back(edge.size() - 1);\\\",\\n    \\\" \\\",\\n    \\\"    }\\\",\\n    \\\" \\\",\\n    \\\"    void bfs(int u) {\\\",\\n    \\\" \\\",\\n    \\\"        queue<int> q;\\\",\\n    \\\"        q.push(u);\\\",\\n    \\\" \\\",\\n    \\\"        while (!q.empty()) {\\\",\\n    \\\" \\\",\\n    \\\"            int u = q.front();\\\",\\n    \\\"            q.pop();\\\",\\n    \\\" \\\",\\n    \\\"            for (int x : idEdge[u])\\\",\\n    \\\"                if (trace[edge[x].v] == -1 && edge[x].flow) {\\\",\\n    \\\"    \\\",\\n    \\\"                    trace[edge[x].v] = x;\\\",\\n    \\\"                    q.push(edge[x].v);\\\",\\n    \\\"    \\\",\\n    \\\"                }\\\",\\n    \\\" \\\",\\n    \\\"        }\\\",\\n    \\\" \\\",\\n    \\\"    }\\\",\\n    \\\" \\\",\\n    \\\"    bool increaseFlow() {\\\",\\n    \\\" \\\",\\n    \\\"        for (int i = 1; i <= n; i++)\\\",\\n    \\\"            trace[i] = -1;\\\",\\n    \\\"        trace[s] = 0;\\\",\\n    \\\" \\\",\\n    \\\"        bfs(s);\\\",\\n    \\\" \\\",\\n    \\\"        if (trace[t] == -1)\\\",\\n    \\\"            return false;\\\",\\n    \\\" \\\",\\n    \\\"        vector<int> V;\\\",\\n    \\\" \\\",\\n    \\\"        int increase = INF;\\\",\\n    \\\" \\\",\\n    \\\"        int sink = t;\\\",\\n    \\\"        while (sink != s) {\\\",\\n    \\\" \\\",\\n    \\\"            minimize(increase, edge[trace[sink]].flow);\\\",\\n    \\\"            V.push_back(trace[sink]);\\\",\\n    \\\"            sink = edge[trace[sink]].u;\\\",\\n    \\\" \\\",\\n    \\\"        }\\\",\\n    \\\" \\\",\\n    \\\"        for (int x : V) {\\\",\\n    \\\" \\\",\\n    \\\"            edge[x].flow -= increase;\\\",\\n    \\\"            edge[x ^ 1].flow += increase;\\\",\\n    \\\" \\\",\\n    \\\"        }\\\",\\n    \\\" \\\",\\n    \\\"        maximumflow += increase;\\\",\\n    \\\" \\\",\\n    \\\"        return increase;\\\",\\n    \\\" \\\",\\n    \\\"    }\\\",\\n    \\\" \\\",\\n    \\\"    vector<pair<int, int>> minCut() {\\\",\\n    \\\" \\\",\\n    \\\"        vector<pair<int, int>> a;\\\",\\n    \\\"        vector<int> S;\\\",\\n    \\\"        stack<int> Q;\\\",\\n    \\\"        for (int i = 1; i <= n; i++)\\\",\\n    \\\"            visited[i] = false;\\\",\\n    \\\"        \\\",\\n    \\\"        Q.push(s);\\\",\\n    \\\"        visited[s] = 1;\\\",\\n    \\\"        while (Q.size()) {\\\",\\n    \\\" \\\",\\n    \\\"            int u = Q.top();\\\",\\n    \\\"            Q.pop();\\\",\\n    \\\"            S.push_back(u);\\\",\\n    \\\" \\\",\\n    \\\"            for (int x : idEdge[u])\\\",\\n    \\\"                if (!visited[edge[x].v] && edge[x].flow) {\\\",\\n    \\\" \\\",\\n    \\\"                    Q.push(edge[x].v);                \\\",\\n    \\\"                    visited[edge[x].v] = true;\\\",\\n    \\\" \\\",\\n    \\\"                }\\\",\\n    \\\"        }\\\",\\n    \\\" \\\",\\n    \\\"        for (int i = 1; i <= n; i++)\\\",\\n    \\\"            for (int x : idEdge[i])\\\",\\n    \\\"                if (visited[i] && !visited[edge[x].v])\\\",\\n    \\\"                    a.push_back(make_pair(i, edge[x].v));\\\",\\n    \\\" \\\",\\n    \\\"        return a;\\\",\\n    \\\" \\\",\\n    \\\"    }\\\",\\n    \\\" \\\",\\n    \\\"    int Maching() {\\\",\\n    \\\" \\\",\\n    \\\"        do {\\\",\\n    \\\" \\\",\\n    \\\"            if (!increaseFlow()) \\\",\\n    \\\"                break;\\\",\\n    \\\" \\\",\\n    \\\"        } while (true);\\\",\\n    \\\" \\\",\\n    \\\"        return maximumflow;\\\",\\n    \\\" \\\",\\n    \\\"    }\\\",\\n    \\\" \\\",\\n    \\\"} flow;\\\"\\n  ],\\n  \\\"description\\\": \\\"Graph - MinCut\\\"\\n}\\n}\",\"MinEuclidDistance.code-snippets\":\"{\\n\\\"Geometry - MinEuclidDistance\\\": {\\n  \\\"prefix\\\": \\\"Geometry - MinEuclidDistance\\\",\\n  \\\"body\\\": [\\n    \\\"long long minED(int l, int r, vector<point> & p) {\\\",\\n    \\\"    if (r - l + 1 <= 8) {\\\",\\n    \\\"        long long minDist = distancePw2(p[l], p[r]);\\\",\\n    \\\"        for (int i = l; i < r; i++)\\\",\\n    \\\"            for (int j = i + 1; j <= r; j++)\\\",\\n    \\\"                minDist = min(minDist, distancePw2(p[i], p[j]));\\\",\\n    \\\"        return minDist;\\\",\\n    \\\"    }\\\",\\n    \\\" \\\",\\n    \\\"    int mid = (l + r) >> 1;\\\",\\n    \\\"    int xmid = p[mid].x;\\\",\\n    \\\"    long long minDist = min(minED(l, mid, p), minED(mid + 1, r, p));\\\",\\n    \\\"\\\",\\n    \\\"    sort(p.begin() + l, p.begin() + mid + 1, [&](point A, point B) {\\\",\\n    \\\"        if (A.y != B.y)\\\",\\n    \\\"            return A.y < B.y;\\\",\\n    \\\"        \\\",\\n    \\\"        return A.x < B.x;\\\",\\n    \\\"    });\\\",\\n    \\\"\\\",\\n    \\\"    sort(p.begin() + mid + 1, p.begin() + r + 1, [&](point A, point B) {\\\",\\n    \\\"        if (A.y != B.y)\\\",\\n    \\\"            return A.y < B.y;\\\",\\n    \\\"        \\\",\\n    \\\"        return A.x < B.x;\\\",\\n    \\\"    });\\\",\\n    \\\" \\\",\\n    \\\"    deque<point> q;\\\",\\n    \\\" \\\",\\n    \\\"    int j = mid;\\\",\\n    \\\"    for (int i = l; i <= mid; i++) {\\\",\\n    \\\"        while (j + 1 <= r && (p[j + 1].y < p[i].y || (p[j + 1].y - p[i].y) * (p[j + 1].y - p[i].y) <= minDist)) {\\\",\\n    \\\"            j++;\\\",\\n    \\\"            if ((p[j].x - xmid) * (p[j].x - xmid) <= minDist)\\\",\\n    \\\"                q.push_back(p[j]);\\\",\\n    \\\"        }\\\",\\n    \\\"\\\",\\n    \\\"        while (q.size() && (q.front().y - p[i].y) * (q.front().y - p[i].y) > minDist)\\\",\\n    \\\"            q.pop_front();\\\",\\n    \\\" \\\",\\n    \\\"        for (point x : q)\\\",\\n    \\\"            minDist = min(minDist, distancePw2(p[i], x));\\\",\\n    \\\"    }\\\",\\n    \\\" \\\",\\n    \\\"    return minDist;\\\",\\n    \\\"}\\\"\\n  ],\\n  \\\"description\\\": \\\"Geometry - MinEuclidDistance\\\"\\n}\\n}\",\"Modular.code-snippets\":\"{\\r\\n\\\"Math - Modular\\\": {\\r\\n  \\\"prefix\\\": \\\"Math - Modular\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"template<int mod = 1000000007>\\\",\\r\\n    \\\"struct Modular {\\\",\\r\\n    \\\"    int value;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    Modular (int v) {value = v;}\\\",\\r\\n    \\\"    Modular& operator += (Modular const& a) {\\\",\\r\\n    \\\"        value += a.value; \\\",\\r\\n    \\\"        if (value >= mod) \\\",\\r\\n    \\\"            value -= mod; \\\",\\r\\n    \\\"        \\\",\\r\\n    \\\"        return *this;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    Modular& operator -= (Modular const& a) {\\\",\\r\\n    \\\"        value -= a.value; \\\",\\r\\n    \\\"        if (value < 0) \\\",\\r\\n    \\\"            value += mod; \\\",\\r\\n    \\\"        \\\",\\r\\n    \\\"        return *this;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"    \\\",\\r\\n    \\\"    Modular& operator *= (Modular const& a) {\\\",\\r\\n    \\\"        value = 1ll * value * a.value % mod; \\\",\\r\\n    \\\"    \\\",\\r\\n    \\\"        return *this;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    friend Modular fastPow(Modular a, auto n) {\\\",\\r\\n    \\\"        Modular ans = 1;\\\",\\r\\n    \\\"        while(n) {\\\",\\r\\n    \\\"            if (n & 1) \\\",\\r\\n    \\\"                ans *= a;\\\",\\r\\n    \\\"                \\\",\\r\\n    \\\"            n >>= 1, a *= a;\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"    \\\",\\r\\n    \\\"        return ans;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    friend Modular inverse(Modular a) {\\\",\\r\\n    \\\"        return fastPow(a, mod - 2);\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    Modular& operator /= (Modular const& a) {\\\",\\r\\n    \\\"        return *this *= inverse(a);\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"    \\\",\\r\\n    \\\"    friend Modular operator + (Modular a, Modular const b) {\\\",\\r\\n    \\\"        return a += b;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"    \\\",\\r\\n    \\\"    friend Modular operator - (Modular a, Modular const b) {\\\",\\r\\n    \\\"        return a -= b;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    friend Modular operator - (Modular const a) {\\\",\\r\\n    \\\"        return 0ll - a;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"    \\\",\\r\\n    \\\"    friend Modular operator * (Modular a, Modular const b) {\\\",\\r\\n    \\\"        return a *= b;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"   \\\",\\r\\n    \\\"    friend Modular operator / (Modular a, Modular const b) {\\\",\\r\\n    \\\"        return a /= b;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    friend std::ostream& operator << (std::ostream& os, Modular const& a) {\\\",\\r\\n    \\\"        return os << a.value;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"    \\\",\\r\\n    \\\"    friend bool operator == (Modular const& a, Modular const& b) {\\\",\\r\\n    \\\"        return a.value == b.value;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"    \\\",\\r\\n    \\\"    friend bool operator != (Modular const& a, Modular const& b) {\\\",\\r\\n    \\\"        return a.value != b.value;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"};\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Math - Modular\\\"\\r\\n}\\r\\n}\",\"NchooseK.code-snippets\":\"{\\r\\n\\\"Math - NChooseK\\\": {\\r\\n  \\\"prefix\\\": \\\"Math - NChooseK\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"int fac[N], finv[N], inv[N];\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"int nChoosek(int n, int k) {\\\",\\r\\n    \\\"    if (n < k || k < 0)\\\",\\r\\n    \\\"        return 0;\\\",\\r\\n    \\\"    \\\",\\r\\n    \\\"    return 1ll * fac[n] * finv[k] % mod * finv[n - k] % mod;\\\",\\r\\n    \\\"}\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"void prepare(int n) {\\\",\\r\\n    \\\"    fac[0] = finv[0] = inv[0] = 1;\\\",\\r\\n    \\\"    fac[1] = finv[1] = inv[1] = 1;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    for (int i = 2; i <= n; i++) {\\\",\\r\\n    \\\"        fac[i] = 1ll * fac[i - 1] * i % mod;\\\",\\r\\n    \\\"        inv[i] = (mod - 1ll * mod / i * inv[mod % i] % mod) % mod;        \\\",\\r\\n    \\\"        finv[i] = 1ll * finv[i - 1] * inv[i] % mod;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"}\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Math - NChooseK\\\"\\r\\n}\\r\\n}\",\"Ordered_Set.code-snippets\":\"{\\n\\\"Data structures - Ordered_Set\\\": {\\n  \\\"prefix\\\": \\\"Data structures - Ordered_Set\\\",\\n  \\\"body\\\": [\\n    \\\"#include <ext/pb_ds/assoc_container.hpp>\\\",\\n    \\\"using namespace __gnu_pbds;\\\",\\n    \\\"\\\",\\n    \\\"#define ordered_set tree<int, null_type,less_equal<int>, rb_tree_tag,tree_order_statistics_node_update>\\\"\\n  ],\\n  \\\"description\\\": \\\"Data structures - Ordered_Set\\\"\\n}\\n}\",\"Parallel.code-snippets\":\"{\\n\\\"Geometry - Parallel\\\": {\\n  \\\"prefix\\\": \\\"Geometry - Parallel\\\",\\n  \\\"body\\\": [\\n    \\\"bool parallel(line l1, line l2) {\\\",\\n    \\\"    double D = l1.a * l2.b - l2.a * l1.b;\\\",\\n    \\\"    return (D == 0);\\\",\\n    \\\"}\\\"\\n  ],\\n  \\\"description\\\": \\\"Geometry - Parallel\\\"\\n}\\n}\",\"PersistentSegmentTree.code-snippets\":\"{\\r\\n\\\"Data Structures - PersistentSegTree\\\": {\\r\\n  \\\"prefix\\\": \\\"Data Structures - PersistentSegTree\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"struct PersistentSegTree {\\\",\\r\\n    \\\"    int numNode;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    PersistentSegTree() {numNode = 1;}\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    struct node {\\\",\\r\\n    \\\"        int leftID, rightID, sum;\\\",\\r\\n    \\\"        node () {leftID = rightID = sum = 0;}\\\",\\r\\n    \\\"        node(int leftID, int rightID, int sum) : leftID(leftID), rightID(rightID), sum(sum) {};\\\",\\r\\n    \\\"    } S[20 * N];\\\",\\r\\n    \\\"    \\\",\\r\\n    \\\"    void build(int id, int l, int r) {\\\",\\r\\n    \\\"        if (l == r) {\\\",\\r\\n    \\\"            S[id] = node(0, 0, a[l]);\\\",\\r\\n    \\\"            return;\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        int mid = l + r >> 1;\\\",\\r\\n    \\\"        \\\",\\r\\n    \\\"        S[id].leftID = ++numNode;\\\",\\r\\n    \\\"        S[id].rightID = ++numNode;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        build(S[id].leftID, l, mid);\\\",\\r\\n    \\\"        build(S[id].rightID, mid + 1, r);\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        S[id].sum = S[S[id].leftID].sum + S[S[id].rightID].sum;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    int update(int id, int l, int r, int p, int x) {\\\",\\r\\n    \\\"        if (p < l || p > r)\\\",\\r\\n    \\\"            return id;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        if (l == r) {\\\",\\r\\n    \\\"            S[++numNode] = node(0, 0, x);\\\",\\r\\n    \\\"            return numNode;\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        int mid = l + r >> 1;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        int idL = update(S[id].leftID, l, mid, p, x);\\\",\\r\\n    \\\"        int idR = update(S[id].rightID, mid + 1, r, p, x);\\\",\\r\\n    \\\"        \\\",\\r\\n    \\\"        numNode++;\\\",\\r\\n    \\\"        S[numNode].leftID = idL;\\\",\\r\\n    \\\"        S[numNode].rightID = idR;\\\",\\r\\n    \\\"        S[numNode].sum = S[idL].sum + S[idR].sum;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        return numNode;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    int get(int id, int l, int r, int u, int v) {\\\",\\r\\n    \\\"        if (r < u || l > v)\\\",\\r\\n    \\\"            return 0;\\\",\\r\\n    \\\"        \\\",\\r\\n    \\\"        if (l >= u && r <= v)\\\",\\r\\n    \\\"            return S[id].sum;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        int mid = (l + r) >> 1;\\\",\\r\\n    \\\"        return get(S[id].leftID, l, mid, u, v) + get(S[id].rightID, mid + 1, r, u, v);\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"} IT;\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Data Structures - PersistentSegTree\\\"\\r\\n}\\r\\n}\",\"PersistentTrie.code-snippets\":\"{\\n\\\"Data Structures - Persistent Trie\\\": {\\n  \\\"prefix\\\": \\\"Data Structures - Persistent Trie\\\",\\n  \\\"body\\\": [\\n    \\\"struct TrieNode {\\\",\\n    \\\"    TrieNode * child[2];\\\",\\n    \\\"    int cnt;\\\",\\n    \\\"\\\",\\n    \\\"    TrieNode() : cnt(0) {child[0] = child[1] = NULL;};\\\",\\n    \\\"} * root[N];\\\",\\n    \\\"\\\",\\n    \\\"namespace PersistentTrie {\\\",\\n    \\\"    //Them 1 so vao cuoi day\\\",\\n    \\\"    TrieNode * Insert(int x, int k, TrieNode * pt) {\\\",\\n    \\\"        TrieNode * p = new TrieNode();\\\",\\n    \\\"        if (pt != NULL)\\\",\\n    \\\"            p->child[0] = pt->child[0], p->child[1] = pt->child[1], p->cnt = pt->cnt;\\\",\\n    \\\"\\\",\\n    \\\"        if (k < 0) \\\",\\n    \\\"            return p->cnt++, p;\\\",\\n    \\\"\\\",\\n    \\\"        if (x & (1 << k))\\\",\\n    \\\"            p->child[1] = Insert(x, k - 1, p->child[1]);\\\",\\n    \\\"        else\\\",\\n    \\\"            p->child[0] = Insert(x, k - 1, p->child[0]);\\\",\\n    \\\"\\\",\\n    \\\"        p->cnt = 0;\\\",\\n    \\\"        if (p->child[0] != NULL)\\\",\\n    \\\"            p->cnt += p->child[0]->cnt;\\\",\\n    \\\"\\\",\\n    \\\"        if (p->child[1] != NULL)\\\",\\n    \\\"            p->cnt += p->child[1]->cnt;\\\",\\n    \\\"\\\",\\n    \\\"        return p;\\\",\\n    \\\"    }\\\",\\n    \\\"\\\",\\n    \\\"    //so lon nhat trong doan tu l->r(c la truy van update doan tu 1->c : a[i] ^= c)\\\",\\n    \\\"    int getMax(int l, int r, int x, int c) {\\\",\\n    \\\"        TrieNode * L = root[l - 1], * R = root[r];\\\",\\n    \\\"\\\",\\n    \\\"        x ^= c;\\\",\\n    \\\"        int res = 0;\\\",\\n    \\\"        for (int i = LOG - 1; i >= 0; i--) {\\\",\\n    \\\"            int bit = ((x & (1 << i)) ? 1 : 0), nbit = !bit;\\\",\\n    \\\"\\\",\\n    \\\"            if (R->child[nbit] != NULL && R->child[nbit]->cnt) {\\\",\\n    \\\"                if (L == NULL || L->child[nbit] == NULL || L->child[nbit]->cnt < R->child[nbit]->cnt) {\\\",\\n    \\\"                    res ^= (1 << i);\\\",\\n    \\\"                    R = R->child[nbit];\\\",\\n    \\\"                    if (L != NULL)\\\",\\n    \\\"                        L = L->child[nbit];\\\",\\n    \\\"                }\\\",\\n    \\\"            }   \\\",\\n    \\\"\\\",\\n    \\\"            if ((res & (1 << i)) == 0) {\\\",\\n    \\\"                R = R->child[bit];\\\",\\n    \\\"                if (L != NULL)\\\",\\n    \\\"                    L = L->child[bit];\\\",\\n    \\\"            }\\\",\\n    \\\"        }\\\",\\n    \\\"\\\",\\n    \\\"        return res;\\\",\\n    \\\"    }\\\",\\n    \\\"\\\",\\n    \\\"    //so luong so nho hon x trong doan tu l->r(c la truy van update doan tu 1->c : a[i] ^= c)\\\",\\n    \\\"    int getCnt(int l, int r, int x, int c) {\\\",\\n    \\\"        TrieNode * L = root[l - 1], * R = root[r];\\\",\\n    \\\"\\\",\\n    \\\"        int res = 0;\\\",\\n    \\\"        for (int i = LOG - 1; i >= 0 && R != NULL; i--) {\\\",\\n    \\\"            int bitx = ((x & (1 << i)) ? 1 : 0), bitc = ((c & (1 << i)) ? 1 : 0);\\\",\\n    \\\"\\\",\\n    \\\"            if (bitx && R->child[bitc] != NULL && R->child[bitc]->cnt) {\\\",\\n    \\\"                if (L == NULL || L->child[bitc] == NULL)\\\",\\n    \\\"                    res += R->child[bitc]->cnt;\\\",\\n    \\\"                else\\\",\\n    \\\"                    res += R->child[bitc]->cnt - L->child[bitc]->cnt;\\\",\\n    \\\"            }\\\",\\n    \\\"\\\",\\n    \\\"            if (L != NULL)\\\",\\n    \\\"                L->child[bitx ^ bitc];\\\",\\n    \\\"\\\",\\n    \\\"            R = R->child[bitx ^ bitc];\\\",\\n    \\\"        }\\\",\\n    \\\"\\\",\\n    \\\"        return res;\\\",\\n    \\\"    }\\\",\\n    \\\"\\\",\\n    \\\"    //so lon thu k trong doan tu l->r (c la truy van update doan tu 1->c : a[i] ^= c)\\\",\\n    \\\"    int getKth(int l, int r, int k, int c) {\\\",\\n    \\\"        TrieNode * L = root[l - 1], * R = root[r];\\\",\\n    \\\"\\\",\\n    \\\"        int res = 0;\\\",\\n    \\\"        for (int i = LOG - 1; i >= 0 && R != NULL; i--) {\\\",\\n    \\\"            int bitc = ((c & (1 << i)) ? 1 : 0);\\\",\\n    \\\"\\\",\\n    \\\"            if (R->child[bitc] != NULL) {\\\",\\n    \\\"                int cnt = (R->child[bitc]->cnt);\\\",\\n    \\\"                if (L != NULL && L->child[bitc] != NULL)\\\",\\n    \\\"                    cnt -= L->child[bitc]->cnt;\\\",\\n    \\\"\\\",\\n    \\\"                if (cnt >= k) {\\\",\\n    \\\"                    R = R->child[bitc];\\\",\\n    \\\"                    if (L != NULL)\\\",\\n    \\\"                        L = L->child[bitc];\\\",\\n    \\\"\\\",\\n    \\\"                    continue;\\\",\\n    \\\"                }\\\",\\n    \\\"\\\",\\n    \\\"                k -= cnt;\\\",\\n    \\\"            }\\\",\\n    \\\"\\\",\\n    \\\"            R = R->child[!bitc];\\\",\\n    \\\"            if (L != NULL)\\\",\\n    \\\"                L = L->child[!bitc];\\\",\\n    \\\"\\\",\\n    \\\"            res ^= (1 << i);\\\",\\n    \\\"        }\\\",\\n    \\\"\\\",\\n    \\\"        return res;\\\",\\n    \\\"    }\\\",\\n    \\\"}\\\"\\n  ],\\n  \\\"description\\\": \\\"Data Structures - Persistent Trie\\\"\\n}\\n}\",\"Phi.code-snippets\":\"{\\r\\n\\\"Math - Phi\\\": {\\r\\n  \\\"prefix\\\": \\\"Math - Phi\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"long long phi(long long n) {\\\",\\r\\n    \\\"    long long res = n;\\\",\\r\\n    \\\"    for (int i = 2; i <= sqrt(n); i++)\\\",\\r\\n    \\\"        if (n % i == 0) {\\\",\\r\\n    \\\"            res -= res / i;\\\",\\r\\n    \\\"            while (n % i == 0) \\\",\\r\\n    \\\"                n /= i;\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    if (n > 1)\\\",\\r\\n    \\\"        res -= res / n;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    return res;\\\",\\r\\n    \\\"}\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Math - Phi\\\"\\r\\n}\\r\\n}\",\"PickTheorem.code-snippets\":\"{\\n\\\"Geometry - PickTheorem\\\": {\\n  \\\"prefix\\\": \\\"Geometry - PickTheorem\\\",\\n  \\\"body\\\": [\\n    \\\"pair<long long, long long> pickTheorem(vector<point> & p) {\\\",\\n    \\\"    int sz = p.size();\\\",\\n    \\\"    long long O = 0;\\\",\\n    \\\"    for (int i = 0; i < sz; i++)\\\",\\n    \\\"        O += __gcd((int)abs(p[i].x - p[(i + 1) % sz].x), (int)abs(p[i].y - p[(i + 1) % sz].y));\\\",\\n    \\\"\\\",\\n    \\\"    long long area = 0;\\\",\\n    \\\"    for (int i = 0; i < sz; i++)\\\",\\n    \\\"        area += (p[i].x - p[(i + 1) % sz].x) * (p[i].y + p[(i + 1) % sz].y);\\\",\\n    \\\"    long long I = (abs(area) - O) / 2 + 1;\\\",\\n    \\\"\\\",\\n    \\\"    return make_pair(I, O);\\\",\\n    \\\"}\\\"\\n  ],\\n  \\\"description\\\": \\\"Geometry - PickTheorem\\\"\\n}\\n}\",\"point.code-snippets\":\"{\\n\\\"Geometry - Point\\\": {\\n  \\\"prefix\\\": \\\"Geometry - Point\\\",\\n  \\\"body\\\": [\\n    \\\"struct point {\\\",\\n    \\\"    double x, y;\\\",\\n    \\\"    point() {x = y = 0.0;}\\\",\\n    \\\"    point(double x, double y) : x(x), y(y) {}\\\",\\n    \\\"\\\",\\n    \\\"    point operator + (const point &a) const {return point(x + a.x, y + a.y);}\\\",\\n    \\\"    point operator - (const point &a) const {return point(x - a.x, y - a.y);}\\\",\\n    \\\"    point operator * (double k) const {return point(x * k, y * k);}\\\",\\n    \\\"    point operator / (double k) const {return point(x / k, y / k);}\\\",\\n    \\\"};\\\"\\n  ],\\n  \\\"description\\\": \\\"Geometry - Point\\\"\\n}\\n}\",\"PointInPolygon.code-snippets\":\"{\\n\\\"Geometry - PointInPolygon\\\": {\\n  \\\"prefix\\\": \\\"Geometry - PointInPolygon\\\",\\n  \\\"body\\\": [\\n    \\\"string pointInPolygon(point m, vector<point> & p) {\\\",\\n    \\\"    if (ccw(p[0], p[1], p[2]) < 0)\\\",\\n    \\\"        reverse(p.begin(), p.end());\\\",\\n    \\\"\\\",\\n    \\\"    int sz = p.size();\\\",\\n    \\\"    int cnt = 0;\\\",\\n    \\\"\\\",\\n    \\\"    for (int i = 0; i < sz; i++) {\\\",\\n    \\\"        if (p[i].x <= m.x && m.x < p[(i + 1) % sz].x && ccw(p[i], p[(i + 1) % sz], m) < 0) \\\",\\n    \\\"            cnt++;\\\",\\n    \\\"        else \\\",\\n    \\\"            if (p[(i + 1) % sz].x <= m.x && m.x < p[i].x && ccw(p[(i + 1) % sz], p[i], m) < 0)  \\\",\\n    \\\"                cnt++;\\\",\\n    \\\"\\\",\\n    \\\"        long long s = ccw(p[i], p[(i + 1) % sz], m);\\\",\\n    \\\"\\\",\\n    \\\"        if (s == 0) {\\\",\\n    \\\"            if (m.x >= min(p[i].x, p[(i + 1) % sz].x) && m.x <= max(p[i].x, p[(i + 1) % sz].x))\\\",\\n    \\\"                if (m.y >= min(p[i].y, p[(i + 1) % sz].y) && m.y <= max(p[i].y, p[(i + 1) % sz].y))\\\",\\n    \\\"                    return \\\\\\\"BOUNDARY\\\\\\\";\\\",\\n    \\\"        }\\\",\\n    \\\"    }\\\",\\n    \\\"\\\",\\n    \\\"    return (cnt % 2 ? \\\\\\\"INSIDE\\\\\\\" : \\\\\\\"OUTSIDE\\\\\\\");\\\",\\n    \\\"}\\\"\\n  ],\\n  \\\"description\\\": \\\"Geometry - PointInPolygon\\\"\\n}\\n}\",\"PointToLine.code-snippets\":\"{\\n\\\"Geometry - PointToLine\\\": {\\n  \\\"prefix\\\": \\\"Geometry - PointToLine\\\",\\n  \\\"body\\\": [\\n    \\\"long double PointToLine(point a, point b, point c) {\\\",\\n    \\\"    point AB = b - a;\\\",\\n    \\\"    point AC = c - a;\\\",\\n    \\\"\\\",\\n    \\\"    long double cross = 1.0 * (AB.x * AC.x + AB.y * AC.y) / (AB.x * AB.x + AB.y * AB.y);\\\",\\n    \\\"    if (cross < 0 || cross > 1) {\\\",\\n    \\\"        long double dist1 = sqrt((c.x - a.x) * (c.x - a.x) + (c.y - a.y) * (c.y - a.y));\\\",\\n    \\\"        long double dist2 = sqrt((c.x - b.x) * (c.x - b.x) + (c.y - b.y) * (c.y - b.y));\\\",\\n    \\\"        return min(dist1, dist2);\\\",\\n    \\\"    }\\\",\\n    \\\"\\\",\\n    \\\"    long double A = a.y - b.y, B = b.x - a.x, C = a.x * b.y - a.y * b.x;\\\",\\n    \\\"    return abs(c.x * A + c.y * B + C) / sqrt(A * A + B * B);\\\",\\n    \\\"}\\\"\\n  ],\\n  \\\"description\\\": \\\"Geometry - PointToLine\\\"\\n}\\n}\",\"PolygonArea.code-snippets\":\"{\\n\\\"Geometry - PolygonArea\\\": {\\n  \\\"prefix\\\": \\\"Geometry - PolygonArea\\\",\\n  \\\"body\\\": [\\n    \\\"long double polygonArea(vector<point> p) {\\\",\\n    \\\"    int sz = p.size();\\\",\\n    \\\"\\\",\\n    \\\"    long double area = 0;\\\",\\n    \\\"    for (int i = 0; i < sz; i++)\\\",\\n    \\\"        area += (p[i].x - p[(i + 1) % sz].x) * (p[i].y + p[(i + 1) % sz].y);\\\",\\n    \\\"\\\",\\n    \\\"    return abs(area) / 2;\\\",\\n    \\\"}\\\"\\n  ],\\n  \\\"description\\\": \\\"Geometry - PolygonArea\\\"\\n}\\n}\",\"prepare.code-snippets\":\"{\\n\\t\\\"prepare\\\": {\\n  \\\"prefix\\\": \\\"prepare\\\",\\n  \\\"body\\\": [\\n    \\\"#include <iostream>\\\",\\n    \\\"#include <fstream>\\\",\\n    \\\"#include <string>\\\",\\n    \\\"#include <sys/stat.h>\\\",\\n    \\\"#include <sys/types.h>\\\",\\n    \\\"\\\",\\n    \\\"int main() {\\\",\\n    \\\"    std::string s;\\\",\\n    \\\"    std::cout << \\\\\\\"Nhap chuoi s: \\\\\\\";\\\",\\n    \\\"    std::getline(std::cin, s);\\\",\\n    \\\"\\\",\\n    \\\"    mkdir(s.c_str());\\\",\\n    \\\"\\\",\\n    \\\"    std::string cppFile = s + \\\\\\\"/\\\\\\\" + s + \\\\\\\".cpp\\\\\\\";\\\",\\n    \\\"    std::string buffaloFile = s + \\\\\\\"/buffalo.cpp\\\\\\\";\\\",\\n    \\\"    std::string testFile = s + \\\\\\\"/test.cpp\\\\\\\";\\\",\\n    \\\"    std::string batFile = s + \\\\\\\"/stress.bat\\\\\\\";\\\",\\n    \\\"\\\",\\n    \\\"    // To file s\\\\\\\".cpp\\\\\\\"\\\",\\n    \\\"    std::ofstream sFile(cppFile);\\\",\\n    \\\"    if (sFile.is_open()) {\\\",\\n    \\\"        sFile << \\\\\\\"#include<bits/stdc++.h>\\\\\\\\n\\\\\\\\n\\\\\\\";\\\",\\n    \\\"        sFile << \\\\\\\"using namespace std;\\\\\\\\n\\\\\\\\n\\\\\\\";\\\",\\n    \\\"        sFile << \\\\\\\"using i64 = long long;\\\\\\\\n\\\\\\\";\\\",\\n    \\\"        sFile << \\\\\\\"using u32 = unsigned;\\\\\\\\n\\\\\\\";\\\",\\n    \\\"        sFile << \\\\\\\"using u64 = unsigned long long;\\\\\\\\n\\\\\\\\n\\\\\\\";\\\",\\n    \\\"        sFile << \\\\\\\"#define fi first\\\\\\\\n\\\\\\\";\\\",\\n    \\\"        sFile << \\\\\\\"#define se second\\\\\\\\n\\\\\\\\n\\\\\\\";\\\",\\n    \\\"        sFile << \\\\\\\"template<class A, class B> inline bool maximize(A& x, B y) {\\\\\\\\n\\\\\\\";\\\",\\n    \\\"        sFile << \\\\\\\"    if (x < y) {\\\\\\\\n\\\\\\\";\\\",\\n    \\\"        sFile << \\\\\\\"        x = y;\\\\\\\\n\\\\\\\";\\\",\\n    \\\"        sFile << \\\\\\\"        return true;\\\\\\\\n\\\\\\\";\\\",\\n    \\\"        sFile << \\\\\\\"    } else\\\\\\\\n\\\\\\\";\\\",\\n    \\\"        sFile << \\\\\\\"        return false;\\\\\\\\n\\\\\\\";\\\",\\n    \\\"        sFile << \\\\\\\"};\\\\\\\\n\\\\\\\\n\\\\\\\";\\\",\\n    \\\"        sFile << \\\\\\\"template<class A, class B> inline bool minimize(A& x, B y) {\\\\\\\\n\\\\\\\";\\\",\\n    \\\"        sFile << \\\\\\\"    if (x > y) {\\\\\\\\n\\\\\\\";\\\",\\n    \\\"        sFile << \\\\\\\"        x = y;\\\\\\\\n\\\\\\\";\\\",\\n    \\\"        sFile << \\\\\\\"        return true;\\\\\\\\n\\\\\\\";\\\",\\n    \\\"        sFile << \\\\\\\"    } else\\\\\\\\n\\\\\\\";\\\",\\n    \\\"        sFile << \\\\\\\"        return false;\\\\\\\\n\\\\\\\";\\\",\\n    \\\"        sFile << \\\\\\\"};\\\\\\\\n\\\\\\\\n\\\\\\\";\\\",\\n    \\\"        sFile << \\\\\\\"void komasan() {\\\\\\\\n\\\\\\\";\\\",\\n    \\\"        sFile << \\\\\\\"    \\\\\\\\n\\\\\\\";\\\",\\n    \\\"        sFile << \\\\\\\"}\\\\\\\\n\\\\\\\\n\\\\\\\";\\\",\\n    \\\"        sFile << \\\\\\\"int main() {\\\\\\\\n\\\\\\\";\\\",\\n    \\\"        sFile << \\\\\\\"    ios_base::sync_with_stdio(false); \\\\\\\\n\\\\\\\";\\\",\\n    \\\"        sFile << \\\\\\\"    cin.tie(nullptr);\\\\\\\\n\\\\\\\\n\\\\\\\";\\\",\\n    \\\"        sFile << \\\\\\\"    // freopen(\\\\\\\\\\\\\\\"\\\\\\\" << s << \\\\\\\".inp\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"r\\\\\\\\\\\\\\\", stdin);\\\\\\\\n\\\\\\\";\\\",\\n    \\\"        sFile << \\\\\\\"    // freopen(\\\\\\\\\\\\\\\"\\\\\\\" << s << \\\\\\\".out\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"w\\\\\\\\\\\\\\\", stdout);\\\\\\\\n\\\\\\\\n\\\\\\\";\\\",\\n    \\\"        sFile << \\\\\\\"    komasan();\\\\\\\\n\\\\\\\";\\\",\\n    \\\"        sFile << \\\\\\\"}\\\\\\\\n\\\\\\\";\\\",\\n    \\\"        sFile.close();\\\",\\n    \\\"        sFile.close();\\\",\\n    \\\"    }\\\",\\n    \\\"\\\",\\n    \\\"    // To file \\\\\\\"buffalo.cpp\\\\\\\"\\\",\\n    \\\"    std::ofstream buffalo(buffaloFile);\\\",\\n    \\\"    if (buffalo.is_open()) {\\\",\\n    \\\"        buffalo << R\\\\\\\"(#include<bits/stdc++.h>\\\",\\n    \\\"using namespace std;\\\",\\n    \\\"\\\",\\n    \\\"using i64 = long long;\\\",\\n    \\\"using u32 = unsigned;\\\",\\n    \\\"using u64 = unsigned long long;\\\",\\n    \\\"\\\",\\n    \\\"#define fi first\\\",\\n    \\\"#define se second\\\",\\n    \\\"\\\",\\n    \\\"template<class A, class B> inline bool maximize(A& x, B y) {\\\",\\n    \\\"    if (x < y) {\\\",\\n    \\\"        x = y;\\\",\\n    \\\"        return true;\\\",\\n    \\\"    } else\\\",\\n    \\\"        return false;\\\",\\n    \\\"};\\\",\\n    \\\"\\\",\\n    \\\"template<class A, class B> inline bool minimize(A& x, B y) {\\\",\\n    \\\"    if (x > y) {\\\",\\n    \\\"        x = y;\\\",\\n    \\\"        return true;\\\",\\n    \\\"    } else\\\",\\n    \\\"        return false;\\\",\\n    \\\"};\\\",\\n    \\\"\\\",\\n    \\\"void komasan() {\\\",\\n    \\\"    \\\",\\n    \\\"}\\\",\\n    \\\"\\\",\\n    \\\"int main() {\\\",\\n    \\\"    ios_base::sync_with_stdio(false); \\\",\\n    \\\"    cin.tie(nullptr);\\\",\\n    \\\"    \\\",\\n    \\\"    // freopen(\\\\\\\".inp\\\\\\\", \\\\\\\"r\\\\\\\", stdin);\\\",\\n    \\\"    // freopen(\\\\\\\".out\\\\\\\", \\\\\\\"w\\\\\\\", stdout);\\\",\\n    \\\"    \\\",\\n    \\\"    komasan();\\\",\\n    \\\"}\\\",\\n    \\\")\\\\\\\";\\\",\\n    \\\"        buffalo.close();\\\",\\n    \\\"    }\\\",\\n    \\\"\\\",\\n    \\\"    std::ofstream test(testFile);\\\",\\n    \\\"    if (test.is_open()) {\\\",\\n    \\\"        test << R\\\\\\\"(#include<bits/stdc++.h>\\\",\\n    \\\"using namespace std;\\\",\\n    \\\"\\\",\\n    \\\"using i64 = long long;\\\",\\n    \\\"using u32 = unsigned;\\\",\\n    \\\"using u64 = unsigned long long;\\\",\\n    \\\"\\\",\\n    \\\"#define fi first\\\",\\n    \\\"#define se second\\\",\\n    \\\"\\\",\\n    \\\"template<class A, class B> inline bool maximize(A& x, B y) {\\\",\\n    \\\"    if (x < y) {\\\",\\n    \\\"        x = y;\\\",\\n    \\\"        return true;\\\",\\n    \\\"    } else\\\",\\n    \\\"        return false;\\\",\\n    \\\"};\\\",\\n    \\\"\\\",\\n    \\\"template<class A, class B> inline bool minimize(A& x, B y) {\\\",\\n    \\\"    if (x > y) {\\\",\\n    \\\"        x = y;\\\",\\n    \\\"        return true;\\\",\\n    \\\"    } else\\\",\\n    \\\"        return false;\\\",\\n    \\\"};\\\",\\n    \\\"\\\",\\n    \\\"mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\\\",\\n    \\\"int Rand(int l, int r) {\\\",\\n    \\\"    if (l > r) {\\\",\\n    \\\"        cout << \\\\\\\"Error l > r\\\\\\\\n\\\\\\\";\\\",\\n    \\\"        assert(l > r);\\\",\\n    \\\"    }\\\",\\n    \\\"\\\",\\n    \\\"    return l + abs((int)rng() % (r - l + 1));\\\",\\n    \\\"}\\\",\\n    \\\"\\\",\\n    \\\"void komasan() {\\\",\\n    \\\"    \\\",\\n    \\\"}\\\",\\n    \\\"\\\",\\n    \\\"int main() {\\\",\\n    \\\"    ios_base::sync_with_stdio(false); \\\",\\n    \\\"    cin.tie(nullptr);\\\",\\n    \\\"    \\\",\\n    \\\"    // freopen(\\\\\\\".inp\\\\\\\", \\\\\\\"r\\\\\\\", stdin);\\\",\\n    \\\"    // freopen(\\\\\\\".out\\\\\\\", \\\\\\\"w\\\\\\\", stdout);\\\",\\n    \\\"    \\\",\\n    \\\"    komasan();\\\",\\n    \\\"})\\\\\\\";\\\",\\n    \\\"        test.close();\\\",\\n    \\\"    }\\\",\\n    \\\"\\\",\\n    \\\"    // To file \\\\\\\"stress.bat\\\\\\\"\\\",\\n    \\\"    std::ofstream stress(batFile);\\\",\\n    \\\"    if (stress.is_open()) {\\\",\\n    \\\"        stress << \\\\\\\"@echo off\\\\\\\\n\\\\\\\";\\\",\\n    \\\"        stress << \\\\\\\"for /l %%i in (1, 1, 100000) do (\\\\\\\\n\\\\\\\";\\\",\\n    \\\"        stress << \\\\\\\"    test.exe > test.inp\\\\\\\\n\\\\\\\";\\\",\\n    \\\"        stress << \\\\\\\"    \\\\\\\" + s + \\\\\\\".exe < test.inp > test.out\\\\\\\\n\\\\\\\";\\\",\\n    \\\"        stress << \\\\\\\"    buffalo.exe < test.inp > answer.out\\\\\\\\n\\\\\\\";\\\",\\n    \\\"        stress << \\\\\\\"    fc test.out answer.out > 0 || echo TEST %%i [WA] && type test.inp && goto :out\\\\\\\\n\\\\\\\";\\\",\\n    \\\"        stress << \\\\\\\"    echo TEST %%i [AC]\\\\\\\\n\\\\\\\";\\\",\\n    \\\"        stress << \\\\\\\")\\\\\\\\n\\\\\\\";\\\",\\n    \\\"        stress << \\\\\\\":out\\\\\\\\n\\\\\\\";\\\",\\n    \\\"        stress.close();\\\",\\n    \\\"    }\\\",\\n    \\\"\\\",\\n    \\\"    std::cout << \\\\\\\"Tao thanh cong folder \\\\\\\" << s << \\\\\\\"\\\\\\\\n\\\\\\\";\\\",\\n    \\\"    return 0;\\\",\\n    \\\"}\\\"\\n  ],\\n  \\\"description\\\": \\\"prepare\\\"\\n}\\n}\",\"RadToDeg.code-snippets\":\"{\\n\\\"Geometry - RadToDeg\\\": {\\n  \\\"prefix\\\": \\\"Geometry - RadToDeg\\\",\\n  \\\"body\\\": [\\n    \\\"inline double Rad_to_Deg(double rad) {return rad * 180 / PI;}\\\"\\n  ],\\n  \\\"description\\\": \\\"Geometry - RadToDeg\\\"\\n}\\n}\",\"Rand.code-snippets\":\"{\\r\\n\\\"Gen - Rand\\\": {\\r\\n  \\\"prefix\\\": \\\"Gen - Rand\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\\\",\\r\\n    \\\"int Rand(int l, int r) {\\\",\\r\\n    \\\"    if (l > r) {\\\",\\r\\n    \\\"        cout << \\\\\\\"Error l > r\\\\\\\\n\\\\\\\";\\\",\\r\\n    \\\"        assert(l > r);\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    return l + abs((int)rng() % (r - l + 1));\\\",\\r\\n    \\\"}\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Gen - Rand\\\"\\r\\n}\\r\\n}\",\"RandTool.code-snippets\":\"{\\n\\\"Gen - Rand Test Tool\\\": {\\n  \\\"prefix\\\": \\\"Gen - Rand Test Tool\\\",\\n  \\\"body\\\": [\\n    \\\"namespace GeneratorTest {   \\\",\\n    \\\"    mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\\\",\\n    \\\"    int Rand(int l, int r) {\\\",\\n    \\\"        if (l > r) {\\\",\\n    \\\"            cerr << \\\\\\\"Error l > r\\\\\\\\n\\\\\\\";\\\",\\n    \\\"            assert(l > r);\\\",\\n    \\\"        }\\\",\\n    \\\"\\\",\\n    \\\"        return l + abs((int)rng() % (r - l + 1));\\\",\\n    \\\"    }\\\",\\n    \\\"\\\",\\n    \\\"    vector<pair<int, int>> Tree(int n) {\\\",\\n    \\\"        if (n <= 1) {\\\",\\n    \\\"            cerr << \\\\\\\"ERROR GENERATOR TREE\\\\\\\\n\\\\\\\";\\\",\\n    \\\"            assert(false);\\\",\\n    \\\"        }\\\",\\n    \\\"\\\",\\n    \\\"        vector<pair<int, int>> edges;\\\",\\n    \\\"        for (int i = 2; i <= n; i++)\\\",\\n    \\\"            edges.push_back(make_pair(i, Rand(1, i - 1)));\\\",\\n    \\\"        \\\",\\n    \\\"        vector<int> p(n); iota(p.begin(), p.end(), 1);\\\",\\n    \\\"        for (pair<int, int> &x : edges) {\\\",\\n    \\\"            if (Rand(1, 2) == 1)\\\",\\n    \\\"                swap(x.fi, x.se);\\\",\\n    \\\"            \\\",\\n    \\\"            x.fi = p[x.fi - 1], x.se = p[x.se - 1];\\\",\\n    \\\"        }\\\",\\n    \\\"\\\",\\n    \\\"        random_shuffle(edges.begin(), edges.end());\\\",\\n    \\\"\\\",\\n    \\\"        return edges;\\\",\\n    \\\"    }\\\",\\n    \\\"\\\",\\n    \\\"    vector<pair<int, int>> Graph(int n) {\\\",\\n    \\\"        if (n <= 1) {\\\",\\n    \\\"            cerr << \\\\\\\"ERROR GENERATOR GRAPH\\\\\\\\n\\\\\\\";\\\",\\n    \\\"            assert(false);\\\",\\n    \\\"        }\\\",\\n    \\\"\\\",\\n    \\\"        vector<pair<int, int>> edges;\\\",\\n    \\\"        for (int i = 2; i <= n; i++)\\\",\\n    \\\"            edges.push_back(make_pair(i, Rand(1, i - 1)));\\\",\\n    \\\"        \\\",\\n    \\\"        vector<int> p(n); iota(p.begin(), p.end(), 1);\\\",\\n    \\\"        for (pair<int, int> &x : edges) {\\\",\\n    \\\"            x.fi = p[x.fi - 1], x.se = p[x.se - 1];\\\",\\n    \\\"            if (x.fi > x.se)\\\",\\n    \\\"                swap(x.fi, x.se);\\\",\\n    \\\"        }\\\",\\n    \\\"        \\\",\\n    \\\"        int m = Rand(1, min(200000, n * n));\\\",\\n    \\\"        for (int i = 1; i <= m; i++) {\\\",\\n    \\\"            int u = Rand(1, n - 1), v = Rand(u + 1, n);\\\",\\n    \\\"            edges.push_back(make_pair(u, v));\\\",\\n    \\\"        }\\\",\\n    \\\"\\\",\\n    \\\"        sort(edges.begin(), edges.end());\\\",\\n    \\\"        edges.resize(unique(edges.begin(), edges.end()) - edges.begin());\\\",\\n    \\\"        for (pair<int, int> x : edges)\\\",\\n    \\\"            if (Rand(1, 2) == 1)\\\",\\n    \\\"                swap(x.fi, x.se);\\\",\\n    \\\"        random_shuffle(edges.begin(), edges.end());\\\",\\n    \\\"\\\",\\n    \\\"        return edges;\\\",\\n    \\\"    }\\\",\\n    \\\"}\\\"\\n  ],\\n  \\\"description\\\": \\\"Gen - Rand Test Tool\\\"\\n}\\n}\",\"Sack.code-snippets\":\"{\\n\\\"Graph - Sack(Small To Large)\\\": {\\n  \\\"prefix\\\": \\\"Graph - Sack(Small To Large)\\\",\\n  \\\"body\\\": [\\n    \\\"int sz[N];\\\",\\n    \\\"void getSz(int u, int par) {\\\",\\n    \\\"    for (int x : edge[u])\\\",\\n    \\\"        if (x != par)\\\",\\n    \\\"            getSz(x, u), sz[u] += sz[x];\\\",\\n    \\\"    sz[u]++;\\\",\\n    \\\"}\\\",\\n    \\\"\\\",\\n    \\\"vector<int> *vec[N];\\\",\\n    \\\"void sack(int u, int par, bool keep) {\\\",\\n    \\\"    int bigChild = -1;\\\",\\n    \\\"    for (int x : edge[u])\\\",\\n    \\\"        if (x != par && (bigChild == -1 || sz[bigChild] < sz[x]))\\\",\\n    \\\"            bigChild = x;\\\",\\n    \\\"    \\\",\\n    \\\"    for (int x : edge[u])\\\",\\n    \\\"        if (x != par && x != bigChild)\\\",\\n    \\\"            sack(x, u, 0);\\\",\\n    \\\"    \\\",\\n    \\\"    if (bigChild != -1)\\\",\\n    \\\"        sack(bigChild, u, 1), vec[u] = vec[bigChild];\\\",\\n    \\\"    else\\\",\\n    \\\"        vec[u] = new vector<int> ();\\\",\\n    \\\"    vec[u]->push_back(u);\\\",\\n    \\\"    //add u\\\",\\n    \\\"\\\",\\n    \\\"    for (int x : edge[u])\\\",\\n    \\\"        if (x != par && x != bigChild)\\\",\\n    \\\"            for (int v : *vec[x]) {\\\",\\n    \\\"                vec[u]->push_back(v);\\\",\\n    \\\"                //add v\\\",\\n    \\\"            }\\\",\\n    \\\"\\\",\\n    \\\"    if (!keep) {\\\",\\n    \\\"        for (int x : *vec[u]) {\\\",\\n    \\\"            // del x;\\\",\\n    \\\"        }\\\",\\n    \\\"    }\\\",\\n    \\\"}\\\"\\n  ],\\n  \\\"description\\\": \\\"Graph - Sack(Small To Large)\\\"\\n}\\n}\",\"same.code-snippets\":\"{\\n\\\"Geometry - Same\\\": {\\n  \\\"prefix\\\": \\\"Geometry - Same\\\",\\n  \\\"body\\\": [\\n    \\\"bool same(line l1, line l2) {\\\",\\n    \\\"    double Dx = l1.c * l2.b - l2.c * l1.b;\\\",\\n    \\\"    double Dy = l1.a * l2.c - l2.a * l1.c;\\\",\\n    \\\"\\\",\\n    \\\"    return (parallel(l1, l2) && Dx == 0 && Dy == 0);\\\",\\n    \\\"}\\\"\\n  ],\\n  \\\"description\\\": \\\"Geometry - Same\\\"\\n}\\n}\",\"Scc.code-snippets\":\"{\\r\\n\\\"Graph - Scc\\\": {\\r\\n  \\\"prefix\\\": \\\"Graph - Scc\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"int num[N], low[N], deleted[N], timeDfs, scc;\\\",\\r\\n    \\\"stack<int> st;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"void tarjan(int u) {\\\",\\r\\n    \\\"    num[u] = low[u] = ++timeDfs;\\\",\\r\\n    \\\"    st.push(u);\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    for (int v : edge[u]) {\\\",\\r\\n    \\\"        if (deleted[v])\\\",\\r\\n    \\\"            continue;\\\",\\r\\n    \\\"            \\\",\\r\\n    \\\"        if (!num[v]) {\\\",\\r\\n    \\\"            tarjan(v);\\\",\\r\\n    \\\"            low[u] = min(low[u], low[v]);\\\",\\r\\n    \\\"        } else\\\",\\r\\n    \\\"            low[u] = min(low[u], num[v]);\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    if (low[u] == num[u]) {\\\",\\r\\n    \\\"        scc++;\\\",\\r\\n    \\\"        int v;\\\",\\r\\n    \\\"        do {\\\",\\r\\n    \\\"            v = st.top();\\\",\\r\\n    \\\"            st.pop();\\\",\\r\\n    \\\"            deleted[v] = true;\\\",\\r\\n    \\\"        } while (v != u);\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"}\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Graph - Scc\\\"\\r\\n}\\r\\n}\",\"SegTree.code-snippets\":\"{\\n\\\"Data structures - SegTree\\\": {\\n  \\\"prefix\\\": \\\"Data structures - SegTree\\\",\\n  \\\"body\\\": [\\n    \\\"struct SegTree {\\\",\\n    \\\"    struct node {\\\",\\n    \\\"        int value;\\\",\\n    \\\"        node() : value(0) {};\\\",\\n    \\\"        node(int value) : value(value) {};\\\",\\n    \\\" \\\",\\n    \\\"        node operator+ (node a) {\\\",\\n    \\\"            node tmp;\\\",\\n    \\\"            //...\\\",\\n    \\\"            return tmp;\\\",\\n    \\\"        }\\\",\\n    \\\"    } S[4 * N];\\\",\\n    \\\"\\\",\\n    \\\"    void build(int id, int l, int r) {\\\",\\n    \\\"        if (l == r)\\\",\\n    \\\"            return S[id] = node(...), void();\\\",\\n    \\\"\\\",\\n    \\\"        int mid = l + r >> 1;\\\",\\n    \\\"        build(id << 1, l, mid);\\\",\\n    \\\"        build(id << 1 | 1, mid + 1, r);\\\",\\n    \\\"\\\",\\n    \\\"        S[id] = S[id << 1] + S[id << 1 | 1];\\\",\\n    \\\"    }\\\",\\n    \\\"\\\",\\n    \\\"    void update(int id, int l, int r, int p, int k) {\\\",\\n    \\\"        if (l == r)\\\",\\n    \\\"            return S[id] = node(k), void();\\\",\\n    \\\"\\\",\\n    \\\"        int mid = l + r >> 1;\\\",\\n    \\\"        if (p <= mid)\\\",\\n    \\\"            update(id << 1, l, mid, p, k);\\\",\\n    \\\"        else \\\",\\n    \\\"            update(id << 1 | 1, mid + 1, r, p, k);\\\",\\n    \\\"\\\",\\n    \\\"        S[id] = S[id << 1] + S[id << 1 | 1];\\\",\\n    \\\"    }\\\",\\n    \\\"\\\",\\n    \\\"    node get(int id, int l, int r, int u, int v) {\\\",\\n    \\\"        if (r < u || l > v || u > v)\\\",\\n    \\\"            return node();\\\",\\n    \\\"        if (l >= u && r <= v)\\\",\\n    \\\"            return S[id];\\\",\\n    \\\"        \\\",\\n    \\\"        int mid = l + r >> 1;\\\",\\n    \\\"        return get(id << 1, l, mid, u, v) + get(id << 1 | 1, mid + 1, r, u, v);\\\",\\n    \\\"    }\\\",\\n    \\\"} IT;\\\"\\n  ],\\n  \\\"description\\\": \\\"Data structures - SegTree\\\"\\n}\\n}\",\"SegTreeLazy.code-snippets\":\"{\\n\\\"Data structures - SegTreeLazy\\\": {\\n  \\\"prefix\\\": \\\"Data structures - SegTreeLazy\\\",\\n  \\\"body\\\": [\\n    \\\"struct SegTreeLazy {\\\",\\n    \\\"    struct node {\\\",\\n    \\\"        int value, lazy;\\\",\\n    \\\"        node() : value(0), lazy(0) {};\\\",\\n    \\\"        node(int value, int lazy) : value(value), lazy(lazy) {};\\\",\\n    \\\" \\\",\\n    \\\"        node operator+ (node a) {\\\",\\n    \\\"            //..\\\",\\n    \\\"        }\\\",\\n    \\\"    } S[4 * N];\\\",\\n    \\\"\\\",\\n    \\\"    void build(int id, int l, int r) {\\\",\\n    \\\"        if (l == r)\\\",\\n    \\\"            return S[id] = node(a[l], 0), void();\\\",\\n    \\\"\\\",\\n    \\\"        int mid = l + r >> 1;\\\",\\n    \\\"        build(id << 1, l, mid);\\\",\\n    \\\"        build(id << 1 | 1, mid + 1, r);\\\",\\n    \\\"\\\",\\n    \\\"        S[id] = S[id << 1] + S[id << 1 | 1];\\\",\\n    \\\"    }\\\",\\n    \\\"\\\",\\n    \\\"    void pushDown(int id, int l, int r) {\\\",\\n    \\\"        if (!S[id].lazy || l == r)\\\",\\n    \\\"            return;\\\",\\n    \\\"\\\",\\n    \\\"        //..\\\",\\n    \\\"        S[id].lazy = 0;\\\",\\n    \\\"    }\\\",\\n    \\\"\\\",\\n    \\\"    void update(int id, int l, int r, int u, int v, int value) {\\\",\\n    \\\"        if (r < u || l > v)\\\",\\n    \\\"            return;\\\",\\n    \\\"        \\\",\\n    \\\"        pushDown(id, l, r);\\\",\\n    \\\"        \\\",\\n    \\\"        if (l >= u && r <= v) \\\",\\n    \\\"            return S[id] = ..., void();\\\",\\n    \\\"\\\",\\n    \\\"        int mid = l + r >> 1;\\\",\\n    \\\"        update(id << 1, l, mid, u, v, value);\\\",\\n    \\\"        update(id << 1 | 1, mid + 1, r, u, v, value);\\\",\\n    \\\"\\\",\\n    \\\"        S[id] = S[id << 1] + S[id << 1 | 1];\\\",\\n    \\\"    }\\\",\\n    \\\"\\\",\\n    \\\"    node get(int id, int l, int r, int u, int v) {\\\",\\n    \\\"        if (r < u || l > v || u > v)\\\",\\n    \\\"            return node();\\\",\\n    \\\"\\\",\\n    \\\"        pushDown(id, l, r);\\\",\\n    \\\"        if (l >= u && r <= v)\\\",\\n    \\\"            return S[id];\\\",\\n    \\\"        \\\",\\n    \\\"        int mid = l + r >> 1;\\\",\\n    \\\"        return get(id << 1, l, mid, u, v) + get(id << 1 | 1, mid + 1, r, u, v);\\\",\\n    \\\"    }\\\",\\n    \\\"} IT;\\\"\\n  ],\\n  \\\"description\\\": \\\"Data structures - SegTreeLazy\\\"\\n}\\n}\",\"SievePhi.code-snippets\":\"{\\r\\n\\\"Math - SievePhi\\\": {\\r\\n  \\\"prefix\\\": \\\"Math - SievePhi\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"int phi[N];\\\",\\r\\n    \\\"void sievePhi(int n) {\\\",\\r\\n    \\\"    for(int i = 1; i <= n; i++)\\\",\\r\\n    \\\"        phi[i] = i;\\\",\\r\\n    \\\"        \\\",\\r\\n    \\\"    for(int i = 2; i <= n; i++) {\\\",\\r\\n    \\\"        if(phi[i] == i)\\\",\\r\\n    \\\"            for(int j = i; j <= n; j += i)\\\",\\r\\n    \\\"                phi[j] -= phi[j] / i;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"}\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Math - SievePhi\\\"\\r\\n}\\r\\n}\",\"SievePrime.code-snippets\":\"{\\r\\n\\\"Math - SievePrime\\\": {\\r\\n  \\\"prefix\\\": \\\"Math - SievePrime\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"bool P[N];\\\",\\r\\n    \\\"void Sieve(int n) {\\\",\\r\\n    \\\"    P[0] = P[1] = 1;\\\",\\r\\n    \\\"    for (int i = 2; i <= sqrt(n); i++)\\\",\\r\\n    \\\"        if (!P[i])\\\",\\r\\n    \\\"            for (int j = i * i; j <= n; j += i)\\\",\\r\\n    \\\"                P[j] = 1;\\\",\\r\\n    \\\"}\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Math - SievePrime\\\"\\r\\n}\\r\\n}\",\"SievePrimeFactor.code-snippets\":\"{\\r\\n\\\"Math - SievePrimeFactor\\\": {\\r\\n  \\\"prefix\\\": \\\"Math - SievePrimeFactor\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"int D[N], P[N];\\\",\\r\\n    \\\"void sievePrimeFactor(int n) {\\\",\\r\\n    \\\"    P[0] = P[1] = 1;\\\",\\r\\n    \\\"    for (int i = 2; i <= sqrt(n); i++)\\\",\\r\\n    \\\"        if (!P[i])\\\",\\r\\n    \\\"            for (int j = i * i; j <= n; j += i)\\\",\\r\\n    \\\"                P[j] = 1;\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"    for (int i = 2; i <= n; i++)\\\",\\r\\n    \\\"        if (!P[i])\\\",\\r\\n    \\\"            for (int j = i; j <= n; j += i)\\\",\\r\\n    \\\"                D[j] = i;\\\",\\r\\n    \\\"}\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Math - SievePrimeFactor\\\"\\r\\n}\\r\\n}\",\"SievePrimeOnRange.code-snippets\":\"{\\r\\n\\\"Math - SieveOnRange\\\": {\\r\\n  \\\"prefix\\\": \\\"Math - SieveOnRange\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"void SieveOnRange(long long l, long long r) {\\\",\\r\\n    \\\"    vector<bool> P(r - l + 1ll, true);\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    for (long long i = 2ll; i <= sqrt(r); i++)\\\",\\r\\n    \\\"        for (long long j = max(i * i, (l + i - 1ll) / i * i); j <= r; j += i)\\\",\\r\\n    \\\"            P[j - l] = false;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    // for (long long i = max(2ll, l); i <= r; i++)\\\",\\r\\n    \\\"    //     if (P[i - l]) \\\",\\r\\n    \\\"    //         cout << i << ' ';\\\",\\r\\n    \\\"}\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Math - SieveOnRange\\\"\\r\\n}\\r\\n}\",\"SparseTable.code-snippets\":\"{\\r\\n\\\"Data Structures - SparseTable\\\": {\\r\\n  \\\"prefix\\\": \\\"Data Structures - SparseTable\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"struct sparseTable {\\\",\\r\\n    \\\"    int r[N][LOG];\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    void prepare(int n, int *a) {\\\",\\r\\n    \\\"        for (int i = 1; i <= n; i++)\\\",\\r\\n    \\\"            r[i][0] = a[i];\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        for (int j = 1; j < LOG; j++)\\\",\\r\\n    \\\"            for (int i = 1; i <= n - (1 << j) + 1; i++)\\\",\\r\\n    \\\"                r[i][j] = min(r[i][j - 1], r[i + (1 << (j - 1))][j - 1]);\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    int get(int L, int R) {\\\",\\r\\n    \\\"        int lb = (R - L == 0 ? 0 : log2(R - L));\\\",\\r\\n    \\\"        return min(r[L][lb], r[R - (1 << lb) + 1][lb]);\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"}\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Data Structures - SparseTable\\\"\\r\\n}\\r\\n}\",\"SqrtDecomposition.code-snippets\":\"{\\r\\n\\\"Data Structures - SQRT\\\": {\\r\\n  \\\"prefix\\\": \\\"Data Structures - SQRT\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"const int MaxSize = 2e5 + 10, Block = 500;\\\",\\r\\n    \\\"struct SqrtDecomposition {\\\",\\r\\n    \\\"    struct BlockValue {\\\",\\r\\n    \\\"        //..\\\",\\r\\n    \\\"    } B[MaxSize / Block + 5];\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    void build(int p) {\\\",\\r\\n    \\\"        //reset\\\",\\r\\n    \\\"        B[p] = ..;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        for (int i = max(1, p * Block); i < min(n + 1, (p + 1) * Block); i++) {\\\",\\r\\n    \\\"            //..\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    void update(int p) {\\\",\\r\\n    \\\"        //update value for p\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        build(p / Block);\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    void update(int l, int r) {\\\",\\r\\n    \\\"        for (int i = l; i < min(r + 1, (l / Block + 1) * Block); i++) {\\\",\\r\\n    \\\"            //update value for left block\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        for (int i = l / Block + 1; i < r / Block; i++) {\\\",\\r\\n    \\\"            //update value for this block\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        for (int i = max((l / Block + 1) * Block, r / Block * Block); i <= r; i++) {\\\",\\r\\n    \\\"            //update value for right block\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    int get(int l, int r) {\\\",\\r\\n    \\\"        int res = 0;\\\",\\r\\n    \\\"        for (int i = l; i < min(r + 1, (l / Block + 1) * Block); i++) {\\\",\\r\\n    \\\"            //get value for left block\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"        for (int i = l / Block + 1; i < r / Block; i++) {\\\",\\r\\n    \\\"            //get value for this block\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"        for (int i = max((l / Block + 1) * Block, r / Block * Block); i <= r; i++) {\\\",\\r\\n    \\\"            //get value for right block\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        return res;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"} SQRT;\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Data Structures - SQRT\\\"\\r\\n}\\r\\n}\",\"SuffixArray.code-snippets\":\"{\\r\\n\\\"String - SuffixArray\\\": {\\r\\n  \\\"prefix\\\": \\\"String - SuffixArray\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"struct SuffixArray {\\\",\\r\\n    \\\"    int numChar = 256;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    vector<int> buildSA(string s) {\\\",\\r\\n    \\\"        s += \\\\\\\"$\\\\\\\";\\\",\\r\\n    \\\"        \\\",\\r\\n    \\\"        int n = s.size();\\\",\\r\\n    \\\"        vector<int> sa(n, 0), c(n, 0), cnt(max(n, numChar), 0);\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        for (int i = 0; i < n; i++)\\\",\\r\\n    \\\"            cnt[s[i]]++;\\\",\\r\\n    \\\"        for (int i = 1; i < numChar; i++)\\\",\\r\\n    \\\"            cnt[i] += cnt[i - 1];\\\",\\r\\n    \\\"        for (int i = 0; i < n; i++)\\\",\\r\\n    \\\"            sa[--cnt[s[i]]] = i;\\\",\\r\\n    \\\"    \\\",\\r\\n    \\\"        int classes = 1;\\\",\\r\\n    \\\"        for (int i = 1; i < n; i++)\\\",\\r\\n    \\\"            c[sa[i]] = (s[sa[i]] != s[sa[i - 1]] ? classes++ : classes - 1);\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        vector<int> pn(n, 0), cn(n, 0);\\\",\\r\\n    \\\"        for (int i = 0; (1 << i) < n; i++) {\\\",\\r\\n    \\\"            fill(cnt.begin(), cnt.end(), 0);\\\",\\r\\n    \\\"            for (int j = 0; j < n; j++) {\\\",\\r\\n    \\\"                pn[j] = (sa[j] - (1 << i) + n) % n;\\\",\\r\\n    \\\"                cnt[c[pn[j]]]++;\\\",\\r\\n    \\\"            }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"            for (int j = 1; j < classes; j++)\\\",\\r\\n    \\\"                cnt[j] += cnt[j - 1];\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"            for (int j = n - 1; j >= 0; j--)\\\",\\r\\n    \\\"                sa[--cnt[c[pn[j]]]] = pn[j];\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"            classes = 1;\\\",\\r\\n    \\\"            cn[sa[0]] = 0;\\\",\\r\\n    \\\"            for (int j = 1; j < n; j++) {\\\",\\r\\n    \\\"                pair<int, int> tmp1 = make_pair(c[sa[j]], c[(sa[j] + (1 << i)) % n]);\\\",\\r\\n    \\\"                pair<int, int> tmp2 = make_pair(c[sa[j - 1]], c[(sa[j - 1] + (1 << i)) % n]);\\\",\\r\\n    \\\"                cn[sa[j]] = (tmp1 != tmp2 ? classes++ : classes - 1);\\\",\\r\\n    \\\"            }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"            c.swap(cn);\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        sa.erase(sa.begin());\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        return sa;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    vector<int> buildLCP(string s, vector<int> sa) {\\\",\\r\\n    \\\"        int n = s.size();\\\",\\r\\n    \\\"        vector<int> rank(n, 0);\\\",\\r\\n    \\\"        for (int i = 0; i < n; i++)\\\",\\r\\n    \\\"            rank[sa[i]] = i;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        int k = 0;\\\",\\r\\n    \\\"        vector<int> lcp(n , 0);\\\",\\r\\n    \\\"        for (int i = 0; i < n; i++) {\\\",\\r\\n    \\\"            if (rank[i] == n - 1) {\\\",\\r\\n    \\\"                k = 0;\\\",\\r\\n    \\\"                continue;\\\",\\r\\n    \\\"            }\\\",\\r\\n    \\\"        \\\",\\r\\n    \\\"            int j = sa[rank[i] + 1];\\\",\\r\\n    \\\"            while (i + k < n && j + k < n && s[i + k] == s[j + k])\\\",\\r\\n    \\\"                k++;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"            lcp[rank[i]] = k;\\\",\\r\\n    \\\"            \\\",\\r\\n    \\\"            if (k)\\\",\\r\\n    \\\"                k--;\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"        \\\",\\r\\n    \\\"        return lcp;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"} SA;\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"String - SuffixArray\\\"\\r\\n}\\r\\n}\",\"Template.code-snippets\":\"{\\n    \\\"FILE CB\\\": {\\n    \\\"scope\\\": \\\"\\\",\\n    \\\"prefix\\\": \\\"cpp - Full\\\",\\n    \\\"body\\\": [\\n\\n\\\"// #include <ext/pb_ds/assoc_container.hpp>\\\",\\n\\\"#include<bits/stdc++.h>\\\",\\n\\\"\\\",\\n\\\"// using namespace __gnu_pbds;\\\",\\n\\\"using namespace std;\\\",\\n\\\"\\\",\\n\\\"// #define ordered_set tree<int, null_type,less_equal<int>, rb_tree_tag,tree_order_statistics_node_update>\\\",\\n\\\"#define            fi first\\\",\\n\\\"#define            se second\\\",\\n\\\"#define            db double\\\",\\n\\\"#define            ll long long\\\",\\n\\\"#define           ull unsigned long long\\\",\\n\\\"#define           ios ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\\\",\\n\\\"#define     inpout(a) freopen(a\\\\\\\".inp\\\\\\\",\\\\\\\"r\\\\\\\",stdin),freopen(a\\\\\\\".out\\\\\\\",\\\\\\\"w\\\\\\\",stdout)\\\",\\n\\\"\\\",\\n\\\"template<class A,class B> inline void maximize(A& x, B y) {x = max(x, y);};\\\",\\n\\\"template<class A,class B> inline void minimize(A& x, B y) {x = min(x, y);};\\\",\\n\\\"\\\",\\n\\\"const long long INF = 1e18;\\\",\\n\\\"const long long mod = 1e9 + 7;\\\",\\n\\\"const int N = 2e5 + 100;\\\",\\n\\\"\\\",\\n\\\"//int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1};\\\",\\n\\\"//int dy[8] = {-1, 1, 0, 0, -1, 1, -1, 1};\\\",\\n\\\"\\\",\\n\\\"void komasan() {\\\",\\n\\\"\\\",\\n\\\"    \\\",\\n\\\"\\\",\\n\\\"}\\\",\\n\\\"\\\",\\n\\\"int main() {\\\",\\n\\\"    ios;\\\",\\n\\\"    //inpout(\\\\\\\"\\\\\\\");\\\",\\n\\\"    komasan();\\\",\\n\\\"\\\",\\n\\\"}\\\",\\n\\n    ],\\n    \\\"description\\\": \\\"template\\\"\\n    }\\n}\\n\",\"TemplateBasic.code-snippets\":\"{\\n\\t\\\"cpp - basic\\\": {\\n\\t\\\"prefix\\\": \\\"cpp - Basic\\\",\\n\\t\\\"body\\\": [\\n\\t\\t\\\"#include<bits/stdc++.h>\\\",\\n\\t\\t\\\"using namespace std;\\\",\\n\\t\\t\\\"\\\",\\n\\t\\t\\\"int main() {\\\",\\n\\t\\t\\\"    ios_base::sync_with_stdio(false);\\\",\\n\\t\\t\\\"    cin.tie(nullptr);\\\",\\n\\t\\t\\\"\\\",\\n\\t\\t\\\"    $0\\\",\\n\\t\\t\\\"\\\",\\n\\t\\t\\\"    return 0;\\\",\\n\\t\\t\\\"}\\\"\\n\\t],\\n\\t\\\"description\\\": \\\"cpp - basic\\\"\\n\\t}\\n}\",\"TemplateEnough.code-snippets\":\"{\\n\\\"cpp - Enough\\\": {\\n  \\\"prefix\\\": \\\"cpp - Enough\\\",\\n  \\\"body\\\": [\\n    \\\"#include<bits/stdc++.h>\\\",\\n    \\\"\\\",\\n    \\\"using namespace std;\\\",\\n    \\\"\\\",\\n    \\\"using i64 = long long;\\\",\\n    \\\"using u32 = unsigned;\\\",\\n    \\\"using u64 = unsigned long long;\\\",\\n    \\\"\\\",\\n    \\\"#define fi first\\\",\\n    \\\"#define se second\\\",\\n    \\\"\\\",\\n    \\\"template<class A, class B> inline bool maximize(A& x, B y) {\\\",\\n    \\\"    if (x < y) {\\\",\\n    \\\"        x = y;\\\",\\n    \\\"        return true;\\\",\\n    \\\"    } else\\\",\\n    \\\"        return false;\\\",\\n    \\\"};\\\",\\n    \\\"\\\",\\n    \\\"template<class A, class B> inline bool minimize(A& x, B y) {\\\",\\n    \\\"    if (x > y) {\\\",\\n    \\\"        x = y;\\\",\\n    \\\"        return true;\\\",\\n    \\\"    } else\\\",\\n    \\\"        return false;\\\",\\n    \\\"};\\\",\\n    \\\"\\\",\\n    \\\"void komasan() {\\\",\\n    \\\"    $0\\\",\\n    \\\"}\\\",\\n    \\\"\\\",\\n    \\\"int main() {\\\",\\n    \\\"    ios_base::sync_with_stdio(false); \\\",\\n    \\\"    cin.tie(nullptr);\\\",\\n    \\\"    \\\",\\n    \\\"    // freopen(\\\\\\\".inp\\\\\\\", \\\\\\\"r\\\\\\\", stdin);\\\",\\n    \\\"    // freopen(\\\\\\\".out\\\\\\\", \\\\\\\"w\\\\\\\", stdout);\\\",\\n    \\\"    \\\",\\n    \\\"    komasan();\\\",\\n    \\\"}\\\"\\n  ],\\n  \\\"description\\\": \\\"cpp - Enough\\\"\\n}\\n}\",\"TimeRun.code-snippets\":\"{\\n\\\"Gen - Time Run\\\": {\\n  \\\"prefix\\\": \\\"Gen - Time Run\\\",\\n  \\\"body\\\": [\\n    \\\"clock_t begin = clock();\\\",\\n    \\\"\\\",\\n    \\\"clock_t end = clock();\\\",\\n    \\\"cerr<<\\\\\\\"Time run: \\\\\\\"<<(float)(end-begin)/CLOCKS_PER_SEC<<\\\\\\\" s\\\\\\\"<<endl;\\\"\\n  ],\\n  \\\"description\\\": \\\"Gen - Time Run\\\"\\n}\\n}\",\"Treap.code-snippets\":\"{\\r\\n\\\"Data Structures - Treap\\\": {\\r\\n  \\\"prefix\\\": \\\"Data Structures - Treap\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"struct Node {\\\",\\r\\n    \\\"    int value, priority, size, rev, sum;\\\",\\r\\n    \\\"    Node * childL, * childR;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    Node(int value) : value(value), priority(rng()), size(1), rev(0), sum(value), childL(NULL), childR(NULL) {};\\\",\\r\\n    \\\"} * root = NULL;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"struct Treap {\\\",\\r\\n    \\\"    int getSize(Node * node) {\\\",\\r\\n    \\\"        return (node == NULL ? 0 : node->size);\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    void pushDown(Node * node) {\\\",\\r\\n    \\\"        if (node == NULL || !node->rev)\\\",\\r\\n    \\\"            return;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        swap(node->childL, node->childR);\\\",\\r\\n    \\\"        \\\",\\r\\n    \\\"        node->rev = 0;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        if (node->childL != NULL)\\\",\\r\\n    \\\"            node->childL->rev ^= 1;\\\",\\r\\n    \\\"        if (node->childR != NULL)\\\",\\r\\n    \\\"            node->childR->rev ^= 1;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    void pull(Node * node) {\\\",\\r\\n    \\\"        node->sum = node->value;\\\",\\r\\n    \\\"        if (node->childL != NULL)\\\",\\r\\n    \\\"            node->sum += node->childL->sum;\\\",\\r\\n    \\\"        if (node->childR != NULL)\\\",\\r\\n    \\\"            node->sum += node->childR->sum;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    void split(Node * root, Node * &l, Node * &r, int x) {\\\",\\r\\n    \\\"        if (root == NULL)\\\",\\r\\n    \\\"            return void(l = r = NULL);\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        pushDown(root);\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        if (getSize(root->childL) < x) {\\\",\\r\\n    \\\"            split(root->childR, root->childR, r, x - getSize(root->childL) - 1);\\\",\\r\\n    \\\"            l = root, pull(l);\\\",\\r\\n    \\\"        } else {\\\",\\r\\n    \\\"            split(root->childL, l, root->childL, x);\\\",\\r\\n    \\\"            r = root, pull(r);\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        root->size = getSize(root->childL) + getSize(root->childR) + 1;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    void merge(Node * & root, Node * l, Node * r) {\\\",\\r\\n    \\\"        if (l == NULL || r == NULL)\\\",\\r\\n    \\\"            return void(root = (l == NULL ? r : l));\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        pushDown(l);\\\",\\r\\n    \\\"        pushDown(r);\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        if (l->priority < r->priority) {\\\",\\r\\n    \\\"            merge(r->childL, l, r->childL);\\\",\\r\\n    \\\"            root = r, pull(root);\\\",\\r\\n    \\\"        } else {\\\",\\r\\n    \\\"            merge(l->childR, l->childR, r);\\\",\\r\\n    \\\"            root = l, pull(root);\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        root->size = getSize(root->childL) + getSize(root->childR) + 1;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    void reverse(int l, int r) {\\\",\\r\\n    \\\"        Node * A, * B, * C, * D;\\\",\\r\\n    \\\"        split(root, A, B, l - 1);\\\",\\r\\n    \\\"        split(B, C, D, r - l + 1);\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        C->rev = 1;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        merge(root, A, C);\\\",\\r\\n    \\\"        merge(root, root, D);\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    int getSum(int l, int r) {\\\",\\r\\n    \\\"        Node * A, * B, * C, * D;\\\",\\r\\n    \\\"        split(root, A, B, l - 1);\\\",\\r\\n    \\\"        split(B, C, D, r - l + 1);\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        int res = C->sum;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        merge(root, A, C);\\\",\\r\\n    \\\"        merge(root, root, D);\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        return res;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"} treap;\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Data Structures - Treap\\\"\\r\\n}\\r\\n}\",\"Tree.code-snippets\":\"{\\r\\n\\\"Gen - Tree\\\": {\\r\\n  \\\"prefix\\\": \\\"Gen - Tree\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"//n ^ 2 * log\\\",\\r\\n    \\\"void Tree(int n, int maxW) {\\\",\\r\\n    \\\"    n = Rand(1, n);\\\",\\r\\n    \\\"    maxW = Rand(1, maxW);\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    DSU.init(n);\\\",\\r\\n    \\\"    vector<pair<int, int>> edge;\\\",\\r\\n    \\\"    for (int i = 1; i < n; i++)\\\",\\r\\n    \\\"        for (int j = i + 1; j <= n; j++)\\\",\\r\\n    \\\"            if (Rand(1, 2) == 1)\\\",\\r\\n    \\\"                edge.push_back(make_pair(i, j));\\\",\\r\\n    \\\"            else\\\",\\r\\n    \\\"                edge.push_back(make_pair(j, i));\\\",\\r\\n    \\\"    \\\",\\r\\n    \\\"    random_shuffle(edge.begin(), edge.end());\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    cout << n << '\\\\\\\\n';\\\",\\r\\n    \\\"    for (int i = 0; i < edge.size(); i++)\\\",\\r\\n    \\\"        if (DSU.join(edge[i].first, edge[i].second)) {\\\",\\r\\n    \\\"            cout << edge[i].first << ' ' << edge[i].second << ' ';\\\",\\r\\n    \\\"            // cout << Rand(1, maxW) << ' ';\\\",\\r\\n    \\\"            cout << '\\\\\\\\n';\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"}\\\",\\r\\n    \\\"\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Gen - Tree\\\"\\r\\n}\\r\\n}\",\"TwoSat.code-snippets\":\"{\\r\\n\\\"Graph - 2Sat\\\": {\\r\\n  \\\"prefix\\\": \\\"Graph - 2Sat\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"struct TwoSat {\\\",\\r\\n    \\\"    vector<int> edge[N], edgeT[N];\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    void addEdge(char cu, int u, char cv, int v) {\\\",\\r\\n    \\\"        u += (cu == '-' ? n : 0);\\\",\\r\\n    \\\"        v += (cv == '-' ? n : 0);\\\",\\r\\n    \\\"        int nu = (u <= n ? u + n : u - n);\\\",\\r\\n    \\\"        int nv = (v <= n ? v + n : v - n);\\\",\\r\\n    \\\"        edge[nu].push_back(v);\\\",\\r\\n    \\\"        edge[nv].push_back(u);\\\",\\r\\n    \\\"        edgeT[v].push_back(nu);\\\",\\r\\n    \\\"        edgeT[u].push_back(nv);\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    vector<int> topo;\\\",\\r\\n    \\\"    bool visited[N];\\\",\\r\\n    \\\"    int id[N];\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    void dfs(int u) {\\\",\\r\\n    \\\"        visited[u] = 1;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        for (int x : edge[u])\\\",\\r\\n    \\\"            if (!visited[x])\\\",\\r\\n    \\\"                dfs(x);\\\",\\r\\n    \\\"        \\\",\\r\\n    \\\"        topo.push_back(u);\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    void scc(int u, int idScc) {\\\",\\r\\n    \\\"        visited[u] = true;\\\",\\r\\n    \\\"        id[u] = idScc;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        for (int x : edgeT[u])\\\",\\r\\n    \\\"            if (!visited[x])\\\",\\r\\n    \\\"                scc(x, idScc);\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    vector<char> ans;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    bool process() {\\\",\\r\\n    \\\"        memset(visited, 0, sizeof(visited));\\\",\\r\\n    \\\"        \\\",\\r\\n    \\\"        for (int i = 1; i <= 2 * n; i++)\\\",\\r\\n    \\\"            if (!visited[i])    \\\",\\r\\n    \\\"                dfs(i);\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        reverse(topo.begin(), topo.end());\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        int idScc = 0;\\\",\\r\\n    \\\"        memset(visited, 0, sizeof(visited));\\\",\\r\\n    \\\"        for (int x : topo)\\\",\\r\\n    \\\"            if (!visited[x])\\\",\\r\\n    \\\"                scc(x, ++idScc);\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        for (int i = 1; i <= n; i++)\\\",\\r\\n    \\\"            if (id[i] == id[i + n])\\\",\\r\\n    \\\"                return false;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        for (int i = 1; i <= n; i++)\\\",\\r\\n    \\\"            if (id[i] > id[i + n])\\\",\\r\\n    \\\"                ans.push_back('+');\\\",\\r\\n    \\\"            else \\\",\\r\\n    \\\"                ans.push_back('-');\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        return true;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"} twoSat;\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Graph - 2Sat\\\"\\r\\n}\\r\\n}\",\"VirtualTree.code-snippets\":\"{\\r\\n\\\"Graph - VirtualTree\\\": {\\r\\n  \\\"prefix\\\": \\\"Graph - VirtualTree\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"struct VirtualTree {\\\",\\r\\n    \\\"    int sz;\\\",\\r\\n    \\\"    vector<int> adj[N], node;\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"    bool checkChild(int u, int p) {\\\",\\r\\n    \\\"        return (ti[p] <= ti[u] && ti[u] <= to[p]);\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"    void buildTree(vector<int> _node) {\\\",\\r\\n    \\\"        node = _node;\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"        sort(node.begin(), node.end(), [&](int A, int B) {\\\",\\r\\n    \\\"            return ti[A] < ti[B];\\\",\\r\\n    \\\"        });\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"        sz = node.size();\\\",\\r\\n    \\\"        for (int i = 0; i < sz - 1; i++)\\\",\\r\\n    \\\"            node.push_back(LCA.lca(node[i], node[i + 1]));\\\",\\r\\n    \\\"        \\\",\\r\\n    \\\"        sort(node.begin(), node.end(), [&](int A, int B) {\\\",\\r\\n    \\\"            return ti[A] < ti[B];\\\",\\r\\n    \\\"        });\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"        node.resize(unique(node.begin(), node.end()) - node.begin());\\\",\\r\\n    \\\"        sz = node.size();\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"        vector<int> cur = {0};\\\",\\r\\n    \\\"        for (int i = 1; i < sz; i++) {\\\",\\r\\n    \\\"            while (!checkChild(node[i], node[cur.back()])) \\\",\\r\\n    \\\"                cur.pop_back();\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"            int u = i;\\\",\\r\\n    \\\"            int v = cur.back();\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"            adj[v].push_back(u);\\\",\\r\\n    \\\"            cur.push_back(i);\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"};\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Graph - VirtualTree\\\"\\r\\n}\\r\\n}\",\"WaveletTree.code-snippets\":\"{\\r\\n\\\"Data Structures - WaveletTree\\\": {\\r\\n  \\\"prefix\\\": \\\"Data Structures - WaveletTree\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"struct WaveletTree {\\\",\\r\\n    \\\"    WaveletTree * childL, * childR;\\\",\\r\\n    \\\"    vector<int> prefix;\\\",\\r\\n    \\\"    int l, r;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    WaveletTree () {\\\",\\r\\n    \\\"        childL = childR = NULL;\\\",\\r\\n    \\\"        l = r = 0;\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    void build(int posL, int posR, vector<int> & a) {\\\",\\r\\n    \\\"        l = *min_element(a.begin() + posL, a.begin() + posR + 1);\\\",\\r\\n    \\\"        r = *max_element(a.begin() + posL, a.begin() + posR + 1);\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        if (l == r || posL > posR)\\\",\\r\\n    \\\"            return;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        prefix.push_back(0);\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        int mid = l + r >> 1;\\\",\\r\\n    \\\"        for (int i = posL; i <= posR; i++)\\\",\\r\\n    \\\"            prefix.push_back(prefix.back() + (a[i] <= mid));\\\",\\r\\n    \\\"        \\\",\\r\\n    \\\"        int posMid = stable_partition(a.begin() + posL, a.begin() + posR + 1, [&](int x) {\\\",\\r\\n    \\\"            return x <= mid;\\\",\\r\\n    \\\"        }) - a.begin() - 1;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        childL = new WaveletTree;\\\",\\r\\n    \\\"        childL->build(posL, posMid, a);\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        childR = new WaveletTree;\\\",\\r\\n    \\\"        childR->build(posMid + 1, posR, a);\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    int Kth(int posL, int posR, int k) {\\\",\\r\\n    \\\"        if (l == r)\\\",\\r\\n    \\\"            return l;\\\",\\r\\n    \\\"        \\\",\\r\\n    \\\"        int cntL = prefix[posL - 1];\\\",\\r\\n    \\\"        int cntR = prefix[posR];\\\",\\r\\n    \\\"        int quantity = cntR - cntL;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        if (quantity >= k)\\\",\\r\\n    \\\"            return childL->Kth(cntL + 1, cntR, k);\\\",\\r\\n    \\\"        else\\\",\\r\\n    \\\"            return childR->Kth(posL - cntL, posR - cntR, k - quantity);\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    int count(int posL, int posR, int k) {\\\",\\r\\n    \\\"        if (l > k || posL > posR)\\\",\\r\\n    \\\"            return 0;\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"        if (r <= k)\\\",\\r\\n    \\\"            return posR - posL + 1;\\\",\\r\\n    \\\"        \\\",\\r\\n    \\\"        int cntL = prefix[posL - 1];\\\",\\r\\n    \\\"        int cntR = prefix[posR];\\\",\\r\\n    \\\" \\\",\\r\\n    \\\"        return childL->count(cntL + 1, cntR, k) + childR->count(posL - cntL, posR - cntR, k);\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"} wavelet;\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"Data Structures - WaveletTree\\\"\\r\\n}\\r\\n}\",\"Zfunction.code-snippets\":\"{\\r\\n\\\"String - Z\\\": {\\r\\n  \\\"prefix\\\": \\\"String - Z\\\",\\r\\n  \\\"body\\\": [\\r\\n    \\\"vector<int> Zfunction(string s) {\\\",\\r\\n    \\\"    int n = s.size();\\\",\\r\\n    \\\"    vector<int> Z(n);\\\",\\r\\n    \\\"    Z[0] = n;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    for (int i = 1, l = 0, r = 0; i < n; i++) {\\\",\\r\\n    \\\"        if (i <= r)\\\",\\r\\n    \\\"            Z[i] = min(r - i + 1, Z[i - l]);\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        while (i + Z[i] < n && s[Z[i]] == s[i + Z[i]])\\\",\\r\\n    \\\"            Z[i]++;\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"        if (i + Z[i] - 1 > r) {\\\",\\r\\n    \\\"            l = i;\\\",\\r\\n    \\\"            r = i + Z[i] - 1;\\\",\\r\\n    \\\"        }\\\",\\r\\n    \\\"    }\\\",\\r\\n    \\\"\\\",\\r\\n    \\\"    return Z;\\\",\\r\\n    \\\"}\\\"\\r\\n  ],\\r\\n  \\\"description\\\": \\\"String - Z\\\"\\r\\n}\\r\\n}\"}}","globalState":"{\"storage\":{\"workbench.panel.markers.hidden\":\"[{\\\"id\\\":\\\"workbench.panel.markers.view\\\",\\\"isHidden\\\":false}]\",\"workbench.panel.output.hidden\":\"[{\\\"id\\\":\\\"workbench.panel.output\\\",\\\"isHidden\\\":false}]\",\"terminal.hidden\":\"[{\\\"id\\\":\\\"terminal\\\",\\\"isHidden\\\":false}]\",\"workbench.explorer.views.state.hidden\":\"[{\\\"id\\\":\\\"outline\\\",\\\"isHidden\\\":false,\\\"order\\\":3},{\\\"id\\\":\\\"timeline\\\",\\\"isHidden\\\":false,\\\"order\\\":4},{\\\"id\\\":\\\"workbench.explorer.openEditorsView\\\",\\\"isHidden\\\":true,\\\"order\\\":0},{\\\"id\\\":\\\"workbench.explorer.emptyView\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.explorer.fileView\\\",\\\"isHidden\\\":false,\\\"order\\\":2},{\\\"id\\\":\\\"npm\\\",\\\"isHidden\\\":true,\\\"order\\\":5},{\\\"id\\\":\\\"cph.judgeView\\\",\\\"isHidden\\\":false,\\\"order\\\":1},{\\\"id\\\":\\\"cloudcode.gemini.chatView\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"cloudcode.unified.kubernetes.localDevExplorer\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"cloudcode.unified.kubectlExplorer\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"cloudcode.unified.cloudRunExplorer\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"cloudcode.unified.apiExplorer\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"cloudcode.unified.dataprocExplorer\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"cloudcode.unified.notebookExplorer\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"cloudcode.unified.bigQueryDatasetExplorer\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"cloudcode.unified.secretsExplorer\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"cloudcode.unified.gceExplorer\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"cloudcode.unified.apigee.explorer\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"cloudcode.unified.gcfExplorer\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"cloudcode.unified.awsLambdaImporterExplorer\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"cloudcode.unified.cloudStorageExplorer\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"cloudcode.unified.sourceProtectExplorer\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"cloudcode.unified.mcdcSources\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"cloudcode.helpAndFeedbackExplorer\\\",\\\"isHidden\\\":false}]\",\"workbench.scm.views.state.hidden\":\"[{\\\"id\\\":\\\"workbench.scm.repositories\\\",\\\"isHidden\\\":true},{\\\"id\\\":\\\"workbench.scm\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.scm.history\\\",\\\"isHidden\\\":false}]\",\"workbench.view.search.state.hidden\":\"[{\\\"id\\\":\\\"workbench.view.search\\\",\\\"isHidden\\\":false}]\",\"workbench.activity.pinnedViewlets2\":\"[{\\\"id\\\":\\\"workbench.view.explorer\\\",\\\"pinned\\\":true,\\\"visible\\\":true,\\\"order\\\":0},{\\\"id\\\":\\\"workbench.view.search\\\",\\\"pinned\\\":true,\\\"visible\\\":true,\\\"order\\\":1},{\\\"id\\\":\\\"workbench.view.scm\\\",\\\"pinned\\\":true,\\\"visible\\\":true,\\\"order\\\":2},{\\\"id\\\":\\\"workbench.view.debug\\\",\\\"pinned\\\":true,\\\"visible\\\":true,\\\"order\\\":3},{\\\"id\\\":\\\"workbench.view.extensions\\\",\\\"pinned\\\":true,\\\"visible\\\":true,\\\"order\\\":4},{\\\"id\\\":\\\"workbench.view.remote\\\",\\\"pinned\\\":true,\\\"visible\\\":false,\\\"order\\\":4},{\\\"id\\\":\\\"workbench.view.extension.test\\\",\\\"pinned\\\":true,\\\"visible\\\":false,\\\"order\\\":6},{\\\"id\\\":\\\"workbench.view.extension.references-view\\\",\\\"pinned\\\":true,\\\"visible\\\":false,\\\"order\\\":7},{\\\"id\\\":\\\"workbench.view.extension.cph-judge-view-container\\\",\\\"pinned\\\":true,\\\"visible\\\":false,\\\"order\\\":8},{\\\"id\\\":\\\"workbench.view.extension.cmake-view\\\",\\\"pinned\\\":true,\\\"visible\\\":false,\\\"order\\\":9},{\\\"id\\\":\\\"workbench.view.extension.chatgpt-activitybar\\\",\\\"pinned\\\":true,\\\"visible\\\":false,\\\"order\\\":10},{\\\"id\\\":\\\"workbench.panel.chatSidebar\\\",\\\"pinned\\\":true,\\\"visible\\\":false,\\\"order\\\":100},{\\\"id\\\":\\\"workbench.view.sync\\\",\\\"pinned\\\":true,\\\"visible\\\":false},{\\\"id\\\":\\\"userDataProfiles\\\",\\\"pinned\\\":true,\\\"visible\\\":false},{\\\"id\\\":\\\"workbench.view.editSessions\\\",\\\"pinned\\\":true,\\\"visible\\\":false}]\",\"nps/lastSessionDate\":\"Sat Jan 27 2024\",\"nps/sessionCount\":\"9\",\"workbench.view.debug.state.hidden\":\"[{\\\"id\\\":\\\"workbench.debug.welcome\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.debug.variablesView\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.debug.watchExpressionsView\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.debug.callStackView\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.debug.loadedScriptsView\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.debug.breakPointsView\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"jsBrowserBreakpoints\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"jsExcludedCallers\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"CppSshTargetsView\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"jsDebugNetworkTree\\\",\\\"isHidden\\\":false}]\",\"workbench.telemetryOptOutShown\":\"true\",\"workbench.statusbar.hidden\":\"[\\\"status.workspaceTrust.1705364714943\\\",\\\"status.workspaceTrust.595e10a626ac8e45e5c0182413da6e28\\\",\\\"status.workspaceTrust.1705365513119\\\",\\\"status.workspaceTrust.07ab9eafd7a759f4f0efe2961f929380\\\",\\\"status.workspaceTrust.1707635726836\\\",\\\"status.workspaceTrust.1707880308111\\\",\\\"status.workspaceTrust.1708050080109\\\"]\",\"ces/skipSurvey\":\"1.60.2\",\"workbench.view.extension.cph-judge-view-container.state.hidden\":\"[{\\\"id\\\":\\\"cph.judgeView\\\",\\\"isHidden\\\":false}]\",\"workbench.panel.pinnedPanels\":\"[{\\\"id\\\":\\\"workbench.panel.markers\\\",\\\"pinned\\\":true,\\\"visible\\\":true,\\\"order\\\":0},{\\\"id\\\":\\\"workbench.panel.output\\\",\\\"pinned\\\":true,\\\"visible\\\":true,\\\"order\\\":1},{\\\"id\\\":\\\"workbench.panel.testResults\\\",\\\"pinned\\\":true,\\\"visible\\\":false,\\\"order\\\":3},{\\\"id\\\":\\\"terminal\\\",\\\"pinned\\\":true,\\\"visible\\\":true,\\\"order\\\":3},{\\\"id\\\":\\\"~remote.forwardedPortsContainer\\\",\\\"pinned\\\":true,\\\"visible\\\":false,\\\"order\\\":5},{\\\"id\\\":\\\"refactorPreview\\\",\\\"pinned\\\":true,\\\"visible\\\":false},{\\\"id\\\":\\\"workbench.panel.repl\\\",\\\"pinned\\\":true,\\\"visible\\\":true,\\\"order\\\":2}]\",\"cpp.1.lastSessionDate\":\"Tue Jan 30 2024\",\"cpp.1.sessionCount\":\"11\",\"java.2.lastSessionDate\":\"Sun Dec 15 2024\",\"java.2.sessionCount\":\"306\",\"javascript.1.lastSessionDate\":\"Sun Dec 15 2024\",\"javascript.1.sessionCount\":\"306\",\"typescript.1.lastSessionDate\":\"Sun Dec 15 2024\",\"typescript.1.sessionCount\":\"306\",\"colorThemeData\":\"{\\\"id\\\":\\\"vs-dark vscode-theme-defaults-themes-dark_plus-json\\\",\\\"label\\\":\\\"Dark+\\\",\\\"settingsId\\\":\\\"Default Dark+\\\",\\\"themeTokenColors\\\":[{\\\"settings\\\":{\\\"foreground\\\":\\\"#D4D4D4\\\"},\\\"scope\\\":[\\\"meta.embedded\\\",\\\"source.groovy.embedded\\\",\\\"string meta.image.inline.markdown\\\",\\\"variable.legacy.builtin.python\\\"]},{\\\"settings\\\":{\\\"fontStyle\\\":\\\"italic\\\"},\\\"scope\\\":\\\"emphasis\\\"},{\\\"settings\\\":{\\\"fontStyle\\\":\\\"bold\\\"},\\\"scope\\\":\\\"strong\\\"},{\\\"settings\\\":{\\\"foreground\\\":\\\"#000080\\\"},\\\"scope\\\":\\\"header\\\"},{\\\"settings\\\":{\\\"foreground\\\":\\\"#6A9955\\\"},\\\"scope\\\":\\\"comment\\\"},{\\\"settings\\\":{\\\"foreground\\\":\\\"#569cd6\\\"},\\\"scope\\\":\\\"constant.language\\\"},{\\\"settings\\\":{\\\"foreground\\\":\\\"#b5cea8\\\"},\\\"scope\\\":[\\\"constant.numeric\\\",\\\"variable.other.enummember\\\",\\\"keyword.operator.plus.exponent\\\",\\\"keyword.operator.minus.exponent\\\"]},{\\\"settings\\\":{\\\"foreground\\\":\\\"#646695\\\"},\\\"scope\\\":\\\"constant.regexp\\\"},{\\\"settings\\\":{\\\"foreground\\\":\\\"#569cd6\\\"},\\\"scope\\\":\\\"entity.name.tag\\\"},{\\\"settings\\\":{\\\"foreground\\\":\\\"#d7ba7d\\\"},\\\"scope\\\":[\\\"entity.name.tag.css\\\",\\\"entity.name.tag.less\\\"]},{\\\"settings\\\":{\\\"foreground\\\":\\\"#9cdcfe\\\"},\\\"scope\\\":\\\"entity.other.attribute-name\\\"},{\\\"settings\\\":{\\\"foreground\\\":\\\"#d7ba7d\\\"},\\\"scope\\\":[\\\"entity.other.attribute-name.class.css\\\",\\\"source.css entity.other.attribute-name.class\\\",\\\"entity.other.attribute-name.id.css\\\",\\\"entity.other.attribute-name.parent-selector.css\\\",\\\"entity.other.attribute-name.parent.less\\\",\\\"source.css entity.other.attribute-name.pseudo-class\\\",\\\"entity.other.attribute-name.pseudo-element.css\\\",\\\"source.css.less entity.other.attribute-name.id\\\",\\\"entity.other.attribute-name.scss\\\"]},{\\\"settings\\\":{\\\"foreground\\\":\\\"#f44747\\\"},\\\"scope\\\":\\\"invalid\\\"},{\\\"settings\\\":{\\\"fontStyle\\\":\\\"underline\\\"},\\\"scope\\\":\\\"markup.underline\\\"},{\\\"settings\\\":{\\\"fontStyle\\\":\\\"bold\\\",\\\"foreground\\\":\\\"#569cd6\\\"},\\\"scope\\\":\\\"markup.bold\\\"},{\\\"settings\\\":{\\\"fontStyle\\\":\\\"bold\\\",\\\"foreground\\\":\\\"#569cd6\\\"},\\\"scope\\\":\\\"markup.heading\\\"},{\\\"settings\\\":{\\\"fontStyle\\\":\\\"italic\\\"},\\\"scope\\\":\\\"markup.italic\\\"},{\\\"settings\\\":{\\\"fontStyle\\\":\\\"strikethrough\\\"},\\\"scope\\\":\\\"markup.strikethrough\\\"},{\\\"settings\\\":{\\\"foreground\\\":\\\"#b5cea8\\\"},\\\"scope\\\":\\\"markup.inserted\\\"},{\\\"settings\\\":{\\\"foreground\\\":\\\"#ce9178\\\"},\\\"scope\\\":\\\"markup.deleted\\\"},{\\\"settings\\\":{\\\"foreground\\\":\\\"#569cd6\\\"},\\\"scope\\\":\\\"markup.changed\\\"},{\\\"settings\\\":{\\\"foreground\\\":\\\"#6A9955\\\"},\\\"scope\\\":\\\"punctuation.definition.quote.begin.markdown\\\"},{\\\"settings\\\":{\\\"foreground\\\":\\\"#6796e6\\\"},\\\"scope\\\":\\\"punctuation.definition.list.begin.markdown\\\"},{\\\"settings\\\":{\\\"foreground\\\":\\\"#ce9178\\\"},\\\"scope\\\":\\\"markup.inline.raw\\\"},{\\\"settings\\\":{\\\"foreground\\\":\\\"#808080\\\"},\\\"scope\\\":\\\"punctuation.definition.tag\\\"},{\\\"settings\\\":{\\\"foreground\\\":\\\"#569cd6\\\"},\\\"scope\\\":[\\\"meta.preprocessor\\\",\\\"entity.name.function.preprocessor\\\"]},{\\\"settings\\\":{\\\"foreground\\\":\\\"#ce9178\\\"},\\\"scope\\\":\\\"meta.preprocessor.string\\\"},{\\\"settings\\\":{\\\"foreground\\\":\\\"#b5cea8\\\"},\\\"scope\\\":\\\"meta.preprocessor.numeric\\\"},{\\\"settings\\\":{\\\"foreground\\\":\\\"#9cdcfe\\\"},\\\"scope\\\":\\\"meta.structure.dictionary.key.python\\\"},{\\\"settings\\\":{\\\"foreground\\\":\\\"#569cd6\\\"},\\\"scope\\\":\\\"meta.diff.header\\\"},{\\\"settings\\\":{\\\"foreground\\\":\\\"#569cd6\\\"},\\\"scope\\\":\\\"storage\\\"},{\\\"settings\\\":{\\\"foreground\\\":\\\"#569cd6\\\"},\\\"scope\\\":\\\"storage.type\\\"},{\\\"settings\\\":{\\\"foreground\\\":\\\"#569cd6\\\"},\\\"scope\\\":[\\\"storage.modifier\\\",\\\"keyword.operator.noexcept\\\"]},{\\\"settings\\\":{\\\"foreground\\\":\\\"#ce9178\\\"},\\\"scope\\\":[\\\"string\\\",\\\"meta.embedded.assembly\\\"]},{\\\"settings\\\":{\\\"foreground\\\":\\\"#ce9178\\\"},\\\"scope\\\":\\\"string.tag\\\"},{\\\"settings\\\":{\\\"foreground\\\":\\\"#ce9178\\\"},\\\"scope\\\":\\\"string.value\\\"},{\\\"settings\\\":{\\\"foreground\\\":\\\"#d16969\\\"},\\\"scope\\\":\\\"string.regexp\\\"},{\\\"settings\\\":{\\\"foreground\\\":\\\"#569cd6\\\"},\\\"scope\\\":[\\\"punctuation.definition.template-expression.begin\\\",\\\"punctuation.definition.template-expression.end\\\",\\\"punctuation.section.embedded\\\"]},{\\\"settings\\\":{\\\"foreground\\\":\\\"#d4d4d4\\\"},\\\"scope\\\":[\\\"meta.template.expression\\\"]},{\\\"settings\\\":{\\\"foreground\\\":\\\"#9cdcfe\\\"},\\\"scope\\\":[\\\"support.type.vendored.property-name\\\",\\\"support.type.property-name\\\",\\\"source.css variable\\\",\\\"source.coffee.embedded\\\"]},{\\\"settings\\\":{\\\"foreground\\\":\\\"#569cd6\\\"},\\\"scope\\\":\\\"keyword\\\"},{\\\"settings\\\":{\\\"foreground\\\":\\\"#569cd6\\\"},\\\"scope\\\":\\\"keyword.control\\\"},{\\\"settings\\\":{\\\"foreground\\\":\\\"#d4d4d4\\\"},\\\"scope\\\":\\\"keyword.operator\\\"},{\\\"settings\\\":{\\\"foreground\\\":\\\"#569cd6\\\"},\\\"scope\\\":[\\\"keyword.operator.new\\\",\\\"keyword.operator.expression\\\",\\\"keyword.operator.cast\\\",\\\"keyword.operator.sizeof\\\",\\\"keyword.operator.alignof\\\",\\\"keyword.operator.typeid\\\",\\\"keyword.operator.alignas\\\",\\\"keyword.operator.instanceof\\\",\\\"keyword.operator.logical.python\\\",\\\"keyword.operator.wordlike\\\"]},{\\\"settings\\\":{\\\"foreground\\\":\\\"#b5cea8\\\"},\\\"scope\\\":\\\"keyword.other.unit\\\"},{\\\"settings\\\":{\\\"foreground\\\":\\\"#569cd6\\\"},\\\"scope\\\":[\\\"punctuation.section.embedded.begin.php\\\",\\\"punctuation.section.embedded.end.php\\\"]},{\\\"settings\\\":{\\\"foreground\\\":\\\"#9cdcfe\\\"},\\\"scope\\\":\\\"support.function.git-rebase\\\"},{\\\"settings\\\":{\\\"foreground\\\":\\\"#b5cea8\\\"},\\\"scope\\\":\\\"constant.sha.git-rebase\\\"},{\\\"settings\\\":{\\\"foreground\\\":\\\"#d4d4d4\\\"},\\\"scope\\\":[\\\"storage.modifier.import.java\\\",\\\"variable.language.wildcard.java\\\",\\\"storage.modifier.package.java\\\"]},{\\\"settings\\\":{\\\"foreground\\\":\\\"#569cd6\\\"},\\\"scope\\\":\\\"variable.language\\\"},{\\\"settings\\\":{\\\"foreground\\\":\\\"#DCDCAA\\\"},\\\"scope\\\":[\\\"entity.name.function\\\",\\\"support.function\\\",\\\"support.constant.handlebars\\\",\\\"source.powershell variable.other.member\\\",\\\"entity.name.operator.custom-literal\\\"]},{\\\"settings\\\":{\\\"foreground\\\":\\\"#4EC9B0\\\"},\\\"scope\\\":[\\\"support.class\\\",\\\"support.type\\\",\\\"entity.name.type\\\",\\\"entity.name.namespace\\\",\\\"entity.other.attribute\\\",\\\"entity.name.scope-resolution\\\",\\\"entity.name.class\\\",\\\"storage.type.numeric.go\\\",\\\"storage.type.byte.go\\\",\\\"storage.type.boolean.go\\\",\\\"storage.type.string.go\\\",\\\"storage.type.uintptr.go\\\",\\\"storage.type.error.go\\\",\\\"storage.type.rune.go\\\",\\\"storage.type.cs\\\",\\\"storage.type.generic.cs\\\",\\\"storage.type.modifier.cs\\\",\\\"storage.type.variable.cs\\\",\\\"storage.type.annotation.java\\\",\\\"storage.type.generic.java\\\",\\\"storage.type.java\\\",\\\"storage.type.object.array.java\\\",\\\"storage.type.primitive.array.java\\\",\\\"storage.type.primitive.java\\\",\\\"storage.type.token.java\\\",\\\"storage.type.groovy\\\",\\\"storage.type.annotation.groovy\\\",\\\"storage.type.parameters.groovy\\\",\\\"storage.type.generic.groovy\\\",\\\"storage.type.object.array.groovy\\\",\\\"storage.type.primitive.array.groovy\\\",\\\"storage.type.primitive.groovy\\\"]},{\\\"settings\\\":{\\\"foreground\\\":\\\"#4EC9B0\\\"},\\\"scope\\\":[\\\"meta.type.cast.expr\\\",\\\"meta.type.new.expr\\\",\\\"support.constant.math\\\",\\\"support.constant.dom\\\",\\\"support.constant.json\\\",\\\"entity.other.inherited-class\\\"]},{\\\"settings\\\":{\\\"foreground\\\":\\\"#C586C0\\\"},\\\"scope\\\":[\\\"keyword.control\\\",\\\"source.cpp keyword.operator.new\\\",\\\"keyword.operator.delete\\\",\\\"keyword.other.using\\\",\\\"keyword.other.directive.using\\\",\\\"keyword.other.operator\\\",\\\"entity.name.operator\\\"]},{\\\"settings\\\":{\\\"foreground\\\":\\\"#9CDCFE\\\"},\\\"scope\\\":[\\\"variable\\\",\\\"meta.definition.variable.name\\\",\\\"support.variable\\\",\\\"entity.name.variable\\\",\\\"constant.other.placeholder\\\"]},{\\\"settings\\\":{\\\"foreground\\\":\\\"#4FC1FF\\\"},\\\"scope\\\":[\\\"variable.other.constant\\\",\\\"variable.other.enummember\\\"]},{\\\"settings\\\":{\\\"foreground\\\":\\\"#9CDCFE\\\"},\\\"scope\\\":[\\\"meta.object-literal.key\\\"]},{\\\"settings\\\":{\\\"foreground\\\":\\\"#CE9178\\\"},\\\"scope\\\":[\\\"support.constant.property-value\\\",\\\"support.constant.font-name\\\",\\\"support.constant.media-type\\\",\\\"support.constant.media\\\",\\\"constant.other.color.rgb-value\\\",\\\"constant.other.rgb-value\\\",\\\"support.constant.color\\\"]},{\\\"settings\\\":{\\\"foreground\\\":\\\"#CE9178\\\"},\\\"scope\\\":[\\\"punctuation.definition.group.regexp\\\",\\\"punctuation.definition.group.assertion.regexp\\\",\\\"punctuation.definition.character-class.regexp\\\",\\\"punctuation.character.set.begin.regexp\\\",\\\"punctuation.character.set.end.regexp\\\",\\\"keyword.operator.negation.regexp\\\",\\\"support.other.parenthesis.regexp\\\"]},{\\\"settings\\\":{\\\"foreground\\\":\\\"#d16969\\\"},\\\"scope\\\":[\\\"constant.character.character-class.regexp\\\",\\\"constant.other.character-class.set.regexp\\\",\\\"constant.other.character-class.regexp\\\",\\\"constant.character.set.regexp\\\"]},{\\\"settings\\\":{\\\"foreground\\\":\\\"#DCDCAA\\\"},\\\"scope\\\":[\\\"keyword.operator.or.regexp\\\",\\\"keyword.control.anchor.regexp\\\"]},{\\\"settings\\\":{\\\"foreground\\\":\\\"#d7ba7d\\\"},\\\"scope\\\":\\\"keyword.operator.quantifier.regexp\\\"},{\\\"settings\\\":{\\\"foreground\\\":\\\"#569cd6\\\"},\\\"scope\\\":[\\\"constant.character\\\",\\\"constant.other.option\\\"]},{\\\"settings\\\":{\\\"foreground\\\":\\\"#d7ba7d\\\"},\\\"scope\\\":\\\"constant.character.escape\\\"},{\\\"settings\\\":{\\\"foreground\\\":\\\"#C8C8C8\\\"},\\\"scope\\\":\\\"entity.name.label\\\"}],\\\"semanticTokenRules\\\":[{\\\"_selector\\\":\\\"newOperator\\\",\\\"_style\\\":{\\\"_foreground\\\":\\\"#d4d4d4\\\",\\\"_bold\\\":null,\\\"_underline\\\":null,\\\"_italic\\\":null,\\\"_strikethrough\\\":null}},{\\\"_selector\\\":\\\"stringLiteral\\\",\\\"_style\\\":{\\\"_foreground\\\":\\\"#ce9178\\\",\\\"_bold\\\":null,\\\"_underline\\\":null,\\\"_italic\\\":null,\\\"_strikethrough\\\":null}},{\\\"_selector\\\":\\\"customLiteral\\\",\\\"_style\\\":{\\\"_foreground\\\":\\\"#d4d4d4\\\",\\\"_bold\\\":null,\\\"_underline\\\":null,\\\"_italic\\\":null,\\\"_strikethrough\\\":null}},{\\\"_selector\\\":\\\"numberLiteral\\\",\\\"_style\\\":{\\\"_foreground\\\":\\\"#b5cea8\\\",\\\"_bold\\\":null,\\\"_underline\\\":null,\\\"_italic\\\":null,\\\"_strikethrough\\\":null}},{\\\"_selector\\\":\\\"newOperator\\\",\\\"_style\\\":{\\\"_foreground\\\":\\\"#c586c0\\\",\\\"_bold\\\":null,\\\"_underline\\\":null,\\\"_italic\\\":null,\\\"_strikethrough\\\":null}},{\\\"_selector\\\":\\\"stringLiteral\\\",\\\"_style\\\":{\\\"_foreground\\\":\\\"#ce9178\\\",\\\"_bold\\\":null,\\\"_underline\\\":null,\\\"_italic\\\":null,\\\"_strikethrough\\\":null}},{\\\"_selector\\\":\\\"customLiteral\\\",\\\"_style\\\":{\\\"_foreground\\\":\\\"#dcdcaa\\\",\\\"_bold\\\":null,\\\"_underline\\\":null,\\\"_italic\\\":null,\\\"_strikethrough\\\":null}},{\\\"_selector\\\":\\\"numberLiteral\\\",\\\"_style\\\":{\\\"_foreground\\\":\\\"#b5cea8\\\",\\\"_bold\\\":null,\\\"_underline\\\":null,\\\"_italic\\\":null,\\\"_strikethrough\\\":null}}],\\\"extensionData\\\":{\\\"_extensionId\\\":\\\"vscode.theme-defaults\\\",\\\"_extensionIsBuiltin\\\":true,\\\"_extensionName\\\":\\\"theme-defaults\\\",\\\"_extensionPublisher\\\":\\\"vscode\\\"},\\\"themeSemanticHighlighting\\\":true,\\\"colorMap\\\":{\\\"checkbox.border\\\":\\\"#6b6b6b\\\",\\\"editor.background\\\":\\\"#1e1e1e\\\",\\\"editor.foreground\\\":\\\"#d4d4d4\\\",\\\"editor.inactiveSelectionBackground\\\":\\\"#3a3d41\\\",\\\"editorIndentGuide.background1\\\":\\\"#404040\\\",\\\"editorIndentGuide.activeBackground1\\\":\\\"#707070\\\",\\\"editor.selectionHighlightBackground\\\":\\\"#add6ff26\\\",\\\"list.dropBackground\\\":\\\"#383b3d\\\",\\\"activityBarBadge.background\\\":\\\"#007acc\\\",\\\"sideBarTitle.foreground\\\":\\\"#bbbbbb\\\",\\\"input.placeholderForeground\\\":\\\"#a6a6a6\\\",\\\"menu.background\\\":\\\"#252526\\\",\\\"menu.foreground\\\":\\\"#cccccc\\\",\\\"menu.separatorBackground\\\":\\\"#454545\\\",\\\"menu.border\\\":\\\"#454545\\\",\\\"menu.selectionBackground\\\":\\\"#0078d4\\\",\\\"statusBarItem.remoteForeground\\\":\\\"#ffffff\\\",\\\"statusBarItem.remoteBackground\\\":\\\"#16825d\\\",\\\"ports.iconRunningProcessForeground\\\":\\\"#369432\\\",\\\"sideBarSectionHeader.background\\\":\\\"#00000000\\\",\\\"sideBarSectionHeader.border\\\":\\\"#cccccc33\\\",\\\"tab.selectedBackground\\\":\\\"#222222\\\",\\\"tab.selectedForeground\\\":\\\"#ffffffa0\\\",\\\"tab.lastPinnedBorder\\\":\\\"#cccccc33\\\",\\\"list.activeSelectionIconForeground\\\":\\\"#ffffff\\\",\\\"terminal.inactiveSelectionBackground\\\":\\\"#3a3d41\\\",\\\"widget.border\\\":\\\"#303031\\\",\\\"actionBar.toggledBackground\\\":\\\"#383a49\\\"},\\\"watch\\\":false}\",\"workbench.panel.repl.hidden\":\"[{\\\"id\\\":\\\"workbench.panel.repl.view\\\",\\\"isHidden\\\":false}]\",\"memento/gettingStartedService\":\"{\\\"pickAFolderTask-Other\\\":{\\\"done\\\":true},\\\"quickOpen\\\":{\\\"done\\\":true},\\\"installGit\\\":{\\\"done\\\":true},\\\"ms-python.python#pythonWelcome2#python.createPythonFolder\\\":{\\\"done\\\":true},\\\"ms-python.python#pythonDataScienceWelcome#python.createNewNotebook\\\":{\\\"done\\\":true},\\\"quickOpenWeb\\\":{\\\"done\\\":true},\\\"ms-vscode.cpptools#cppWelcome#verify.compiler.mac\\\":{\\\"done\\\":true},\\\"ms-vscode.cpptools#cppWelcome#verify.compiler.linux\\\":{\\\"done\\\":true},\\\"ms-vscode.cpptools#cppWelcome#verify.compiler.windows\\\":{\\\"done\\\":true},\\\"ms-vscode.cpptools#cppWelcome#verify.compiler.windows10\\\":{\\\"done\\\":true},\\\"ms-vscode.cpptools#cppWelcome#verify.compiler.windows11\\\":{\\\"done\\\":true},\\\"ms-vscode-remote.remote-wsl#wslWalkthrough#create.project\\\":{\\\"done\\\":true},\\\"ms-python.python#pythonWelcome#python.createPythonFile\\\":{\\\"done\\\":true},\\\"ms-vscode.cpptools#cppWelcome#create.cpp.file\\\":{\\\"done\\\":true},\\\"ms-python.python#pythonWelcome#python.createPythonFolder\\\":{\\\"done\\\":true},\\\"settingsSync\\\":{\\\"done\\\":true},\\\"settingsSyncWeb\\\":{\\\"done\\\":true},\\\"intellisense\\\":{\\\"done\\\":true},\\\"commandPaletteTask\\\":{\\\"done\\\":true},\\\"commandPaletteTaskWeb\\\":{\\\"done\\\":true},\\\"commandPaletteTaskAccessibility\\\":{\\\"done\\\":true}}\",\"workbench.view.extensions.state.hidden\":\"[{\\\"id\\\":\\\"workbench.views.extensions.installed.empty\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.installed\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.workspaceRecommendations\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.popular\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.otherRecommendations\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"extensions.recommendedList\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.enabled\\\",\\\"isHidden\\\":true},{\\\"id\\\":\\\"workbench.views.extensions.disabled\\\",\\\"isHidden\\\":true},{\\\"id\\\":\\\"workbench.views.extensions.marketplace\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.searchInstalled\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.searchEnabled\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.searchDisabled\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.searchOutdated\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.searchBuiltin\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.searchWorkspaceUnsupported\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.builtinFeatureExtensions\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.builtinThemeExtensions\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.builtinProgrammingLanguageExtensions\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.untrustedUnsupportedExtensions\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.untrustedPartiallySupportedExtensions\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.virtualUnsupportedExtensions\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.virtualPartiallySupportedExtensions\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.searchRecentlyUpdated\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.deprecatedExtensions\\\",\\\"isHidden\\\":false}]\",\"workbench.activityBar.location\":\"default\",\"workbench.view.remote.state.hidden\":\"[{\\\"id\\\":\\\"targetsWsl\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"remoteTargets\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"~remote.helpPanel\\\",\\\"isHidden\\\":false}]\",\"workbench.view.extension.chatgpt-activitybar.state.hidden\":\"[{\\\"id\\\":\\\"chatgpt.sidebar\\\",\\\"isHidden\\\":false}]\",\"csharp.1.lastSessionDate\":\"Sun Dec 15 2024\",\"csharp.1.sessionCount\":\"306\",\"~remote.forwardedPortsContainer.hidden\":\"[{\\\"id\\\":\\\"~remote.forwardedPorts\\\",\\\"isHidden\\\":false}]\",\"workbench.welcomePage.walkthroughMetadata\":\"[[\\\"ms-python.python#pythonWelcome\\\",{\\\"firstSeen\\\":1705365524082,\\\"stepIDs\\\":[\\\"python.createPythonFile\\\",\\\"python.installPythonWin8\\\",\\\"python.installPythonMac\\\",\\\"python.installPythonLinux\\\",\\\"python.selectInterpreter\\\",\\\"python.createEnvironment\\\",\\\"python.runAndDebug\\\",\\\"python.learnMoreWithDS\\\"],\\\"manaullyOpened\\\":false}],[\\\"ms-python.python#pythonWelcome2\\\",{\\\"firstSeen\\\":1705365524082,\\\"stepIDs\\\":[\\\"python.createPythonFolder\\\",\\\"python.createPythonFile\\\",\\\"python.installPythonWin8\\\",\\\"python.installPythonMac\\\",\\\"python.installPythonLinux\\\",\\\"python.createEnvironment2\\\",\\\"python.runAndDebug\\\",\\\"python.learnMoreWithDS2\\\"],\\\"manaullyOpened\\\":false}],[\\\"ms-python.python#pythonDataScienceWelcome\\\",{\\\"firstSeen\\\":1705365524082,\\\"stepIDs\\\":[\\\"python.installJupyterExt\\\",\\\"python.createNewNotebook\\\",\\\"python.openInteractiveWindow\\\",\\\"python.dataScienceLearnMore\\\"],\\\"manaullyOpened\\\":false}],[\\\"ms-vscode-remote.remote-wsl#wslWalkthrough\\\",{\\\"firstSeen\\\":1705365524082,\\\"stepIDs\\\":[\\\"explore.commands\\\",\\\"open.wslwindow\\\",\\\"create.project\\\",\\\"open.project\\\",\\\"linux.environment\\\",\\\"install.tools\\\",\\\"run.debug\\\",\\\"come.back\\\"],\\\"manaullyOpened\\\":false}],[\\\"ms-vscode.cpptools#cppWelcome\\\",{\\\"firstSeen\\\":1705365524082,\\\"stepIDs\\\":[\\\"awaiting.activation.mac\\\",\\\"awaiting.activation.linux\\\",\\\"awaiting.activation.windows\\\",\\\"awaiting.activation.windows10\\\",\\\"awaiting.activation.windows11\\\",\\\"no.compilers.found.mac\\\",\\\"no.compilers.found.linux\\\",\\\"no.compilers.found.windows\\\",\\\"no.compilers.found.windows10\\\",\\\"no.compilers.found.windows11\\\",\\\"verify.compiler.mac\\\",\\\"verify.compiler.linux\\\",\\\"verify.compiler.windows\\\",\\\"verify.compiler.windows10\\\",\\\"verify.compiler.windows11\\\",\\\"create.cpp.file\\\",\\\"relaunch.developer.command.prompt.windows\\\",\\\"run.project.mac\\\",\\\"run.project.linux\\\",\\\"run.project.windows\\\",\\\"customize.debugging.linux\\\",\\\"customize.debugging.windows\\\",\\\"customize.debugging.mac\\\"],\\\"manaullyOpened\\\":false}],[\\\"googlecloudtools.cloudcode#one-activity-bar\\\",{\\\"firstSeen\\\":1721666369165,\\\"stepIDs\\\":[\\\"one_activity_bar\\\",\\\"project_selector\\\",\\\"hide_show_view\\\",\\\"rearrange_view\\\",\\\"split_explorers\\\"],\\\"manaullyOpened\\\":false}],[\\\"googlecloudtools.cloudcode#apigee-gemini\\\",{\\\"firstSeen\\\":1721666369165,\\\"stepIDs\\\":[\\\"magic_wand_button\\\",\\\"enter_prompt\\\",\\\"api_design_experience\\\",\\\"quick_actions\\\"],\\\"manaullyOpened\\\":false}],[\\\"googlecloudtools.cloudcode#apigee-create-specs\\\",{\\\"firstSeen\\\":1721666369165,\\\"stepIDs\\\":[\\\"connect-signed-out\\\",\\\"connect-signed-in\\\",\\\"enable-ai-companion-signed-out\\\",\\\"enable-ai-companion-not-permitted\\\",\\\"enable-ai-companion-disabled\\\",\\\"enable-ai-companion-enabling\\\",\\\"enable-ai-companion-enabled\\\",\\\"integrate-with-hub-signed-out\\\",\\\"integrate-with-hub-not-provisioned\\\",\\\"integrate-with-hub-provisioned\\\",\\\"create-api-specs\\\"],\\\"manaullyOpened\\\":false}],[\\\"googlecloudtools.cloudcode#apigee-create-api-proxies\\\",{\\\"firstSeen\\\":1721666369165,\\\"stepIDs\\\":[\\\"set-up-apigee-workspace-apigee-loading\\\",\\\"set-up-apigee-workspace-no-workspace\\\",\\\"set-up-apigee-workspace-valid-workspace\\\",\\\"build-api-proxies-no-workspace\\\",\\\"build-api-proxies-valid-workspace\\\"],\\\"manaullyOpened\\\":false}]]\",\"themeUpdatedNotificationShown\":\"true\",\"workbench.panel.alignment\":\"center\",\"cpp.1.editedCount\":\"10\",\"cpp.1.editedDate\":\"Mon Jan 29 2024\",\"snippets.usageTimestamps\":\"[[\\\"SieveAndPrime.code-snippets/FILE CB\\\",1726222959069],[\\\"SparseTable.code-snippets/sparseTable \\\",1726226396508],[\\\"TarjanSCC.code-snippets/FILE CB\\\",1726226658274],[\\\"WaveletTree.code-snippets/FILE CB\\\",1726226905490],[\\\"Zfunction.code-snippets/FILE CB\\\",1726245673325],[\\\"EulerPath.code-snippets/FILE CB\\\",1729647020271],[\\\"ConvexHullTrick.code-snippets/FILE CB\\\",1729675052518],[\\\"LichaoTree.code-snippets/LichaoTree\\\",1729683500288],[\\\"Trie.code-snippets/FILE CB\\\",1730952244768],[\\\"LowestCommonAncestorQueryO(1).code-snippets/Graph - LCA (Query O(1))\\\",1731493338540],[\\\"DisjointSetUnion.code-snippets/DisjointSetUnion\\\",1731493589823],[\\\"DSURollback.code-snippets/Graph - DSU Rollback\\\",1731494972432],[\\\"SegmentTreeLazy.code-snippets/SegTreeLazy\\\",1731603098327],[\\\"JointAndBrigde.code-snippets/JointAndBridges\\\",1731733542522],[\\\"TarjanSCC.code-snippets/Graph - SCC (Tarjan)\\\",1731733579444],[\\\"FlowUsingBFS.code-snippets/MaximumFlow\\\",1731733612450],[\\\"Hungari.code-snippets/MaximumMatching\\\",1731923111695],[\\\"MulMatrix.code-snippets/Math - MulMatrix\\\",1732033299323],[\\\"Pow.code-snippets/Math - Pow\\\",1732038753467],[\\\"fastPow.code-snippets/Math - fastPow\\\",1732038818386],[\\\"GaussMod.code-snippets/Math - GaussMod\\\",1732039582653],[\\\"IsPrime.code-snippets/Math - IsPrime\\\",1732040077565],[\\\"Modular.code-snippets/Math - Modular\\\",1732040104881],[\\\"MillerRabin.code-snippets/Math - MillerRabin\\\",1732040551018],[\\\"NChooseK.code-snippets/Math - nChoosek\\\",1732040651446],[\\\"HopcroftKarp.code-snippets/MaximumMatching\\\",1732040887987],[\\\"PointInPolygon.code-snippets/Math - PointInPolygon\\\",1732041123725],[\\\"Phi.code-snippets/Math - Phi\\\",1732041167993],[\\\"SievePhi.code-snippets/Math - SievePhi\\\",1732041186047],[\\\"SievePrimeOnRange.code-snippets/Math - SievePrimeOnRange\\\",1732041258861],[\\\"ConvexHullTrick.code-snippets/Data Structures - ConvexHull Trick\\\",1732068978241],[\\\"FenwickTree.code-snippets/FenwickTree\\\",1732069096033],[\\\"FenwickTree2D.code-snippets/FenwickTree2D\\\",1732069259791],[\\\"LichaoTree.code-snippets/Data Structures - LiChao Tree\\\",1732069595226],[\\\"PersistentSegmentTree.cpp.code-snippets/Data Structures - Persistent Segment Tree\\\",1732069740359],[\\\"SQRTDecomposition.code-snippets/Data Structures - SQRT Decomposition\\\",1732070001319],[\\\"CentroidDecomposition.code-snippets/CentroidDecomposition\\\",1732073767905],[\\\"AhoCorasick.code-snippets/String - Aho Corasick\\\",1732074606677],[\\\"HashingString.code-snippets/Hashing\\\",1732074660847],[\\\"Manachar.code-snippets/Manachar\\\",1732074992749],[\\\"Zfunction.code-snippets/String - Zfunction\\\",1732075432463],[\\\"KMPFunction.code-snippets/String - KMPFunction\\\",1732075461740],[\\\"VirtualTree.code-snippets/Graph - Virtual Tree\\\",1732075524218],[\\\"ConvexHull.code-snippets/ConvexHull\\\",1732075628731],[\\\"Geometry.code-snippets/Geometry\\\",1732075676813],[\\\"GenGraph.code-snippets/Gen - Graph\\\",1732076411212],[\\\"GenTree.code-snippets/Gen - Tree\\\",1732076421567],[\\\"HeavyLightDecomposition.code-snippets/HeavyLightDecomposion \\\",1732089732197],[\\\"LowestCommonAncestor.code-snippets/LowestCommonAncestor \\\",1732090135123],[\\\"SegmentTree.code-snippets/SegmentTree\\\",1732090952684],[\\\"AhoCorasick.code-snippets/String - AhoCorasick\\\",1732094670783],[\\\"Gen.code-snippets/Gen - Gen\\\",1732517908013],[\\\"SievePrime.code-snippets/Math - SievePrime\\\",1732736375132],[\\\"SuffixArray.code-snippets/String - SuffixArray\\\",1732770737175],[\\\"ConvexHullTrick.code-snippets/Data Structures - ConvexHullTrick\\\",1732784895518],[\\\"Manacher.code-snippets/String - Manacher\\\",1732976219842],[\\\"SievePrimeFactor.code-snippets/Math - SievePrimeFactor\\\",1733203078920],[\\\"Tree.code-snippets/Gen - Tree\\\",1733281784939],[\\\"Graph.code-snippets/Gen - Graph\\\",1733283403658],[\\\"Treap.code-snippets/Data Structures - Treap\\\",1733305942625],[\\\"PersistentSegmentTree.code-snippets/Data Structures - PersistentSegTree\\\",1733305977847],[\\\"HeavyLightDecomposition.code-snippets/Graph - HeavyLightDecomposition\\\",1733672809456],[\\\"SparseTable.code-snippets/Data Structures - SparseTable\\\",1734203525090],[\\\"DisjointSetUnion(Heavy Light Set).code-snippets/Graph - DisjointSetUnion(Heavy Light Set)\\\",1734204059918],[\\\"DisjointSetUnion.code-snippets/Graph - DisjointSetUnion\\\",1734204327297],[\\\"DisjointSetUnion.code-snippets/Graph - DSU\\\",1734204384671],[\\\"Scc.code-snippets/Graph - Scc\\\",1734204482327],[\\\"TwoSat.code-snippets/Graph - 2Sat\\\",1734204579101],[\\\"MaximumFlow.code-snippets/Graph - MaximumFlow\\\",1734204959475],[\\\"HopcoftKarp.code-snippets/Graph - HopcoftKarp\\\",1734205119704],[\\\"Hash.code-snippets/String - Hash\\\",1734206101709],[\\\"prepare.code-snippets/prepare\\\",1734269467176],[\\\"VirtualTree.code-snippets/Graph - VirtualTree\\\",1734276023004],[\\\"Rand.code-snippets/Gen - Rand\\\",1734278169768],[\\\"RandTool.code-snippets/Gen - Rand Test Tool\\\",1734450707022],[\\\"PersistentTrie.code-snippets/Data Structures - Persistent Trie\\\",1734450721848],[\\\"WaveletTree.code-snippets/Data Structures - WaveletTree\\\",1734451738665],[\\\"Template.code-snippets/FILE CB\\\",1734452310057],[\\\"Ordered_Set.code-snippets/Data structures - Ordered_Set\\\",1734452444366],[\\\"NchooseK.code-snippets/Math - NChooseK\\\",1734452511407],[\\\"DisjointSetUnion(Rollback).code-snippets/Graph - DisjointSetUnion Rollback\\\",1734454497633],[\\\"SegTree.code-snippets/Data structures - SegTree\\\",1734537365365],[\\\"TemplateBasic.code-snippets/cpp - basic\\\",1734539121848],[\\\"SegTreeLazy.code-snippets/Data structures - SegTreeLazy\\\",1734539126933],[\\\"SqrtDecomposition.code-snippets/Data Structures - SQRT\\\",1734623917686],[\\\"Geometry.code-snippets/Geometry - Geometry\\\",1734623968774],[\\\"MatrixMultiplication.code-snippets/Math - Matrix Multiplication\\\",1734624049055],[\\\"FastPow.code-snippets/Math - FastPow\\\",1734625661859],[\\\"TimeRun.code-snippets/Gen - Time Run\\\",1734625928753],[\\\"Dijkstra.code-snippets/Graph - Dijkstra\\\",1734626726798],[\\\"LowestCommonAncestor(Query O(1)).code-snippets/Graph - LCA(Query O(1))\\\",1734705129291],[\\\"LowestCommonAncestor.code-snippets/Graph - LCA\\\",1734705480833],[\\\"point.code-snippets/Geometry - Point\\\",1734881874558],[\\\"EuclidDistance.code-snippets/Geometry - EuclidDistance\\\",1734887492489],[\\\"Line.code-snippets/Geometry - Line\\\",1734888329545],[\\\"Makeline.code-snippets/Geometry - Makeline\\\",1734888334698],[\\\"TemplateEnough.code-snippets/cpp - Enough\\\",1734888810504],[\\\"Sack.code-snippets/Graph - Sack(Small To Large)\\\",1734888816775],[\\\"cpp.code-snippets/cpp\\\",1734891256055],[\\\"ChuTrinhDon.code-snippets/Graph - ChuTrinhDon\\\",1734891560648]]\",\"terminal.integrated.showTerminalConfigPrompt\":\"false\",\"nps/isCandidate\":\"false\",\"nps/skipVersion\":\"1.85.2\",\"cpp.1.isCandidate\":\"false\",\"cpp.1.skipVersion\":\"1.85.2\",\"expandSuggestionDocs\":\"true\",\"github-VoNgocSinh\":\"[{\\\"id\\\":\\\"vscode.github\\\",\\\"name\\\":\\\"GitHub\\\",\\\"allowed\\\":true},{\\\"id\\\":\\\"vscode.configuration-editing\\\",\\\"name\\\":\\\"Configuration Editing\\\",\\\"allowed\\\":true}]\",\"workbench.view.extension.test.state.hidden\":\"[{\\\"id\\\":\\\"workbench.view.testing\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.view.testCoverage\\\",\\\"isHidden\\\":false}]\",\"commandPalette.mru.cache\":\"{\\\"usesLRU\\\":true,\\\"entries\\\":[{\\\"key\\\":\\\"git.addRemote\\\",\\\"value\\\":4},{\\\"key\\\":\\\"workbench.action.populateFileFromSnippet\\\",\\\"value\\\":6},{\\\"key\\\":\\\"workbench.action.openSnippets\\\",\\\"value\\\":7},{\\\"key\\\":\\\"workbench.action.tasks.configureTaskRunner\\\",\\\"value\\\":12}]}\",\"commandPalette.mru.counter\":\"13\",\"tabs-list-width-horizontal\":\"121\",\"java.2.editedCount\":\"1\",\"java.2.editedDate\":\"Wed Jun 12 2024\",\"remote.explorerType\":\"tunnel,ssh-remote\",\"workbench.view.extension.1-cloudCodeContainer.state.hidden\":\"[{\\\"id\\\":\\\"cloudcode.unified.kubernetes.localDevExplorer\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"cloudcode.unified.kubectlExplorer\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"cloudcode.unified.cloudRunExplorer\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"cloudcode.unified.apiExplorer\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"cloudcode.unified.secretsExplorer\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"cloudcode.unified.gceExplorer\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"cloudcode.unified.apigee.explorer\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"cloudcode.unified.gcfExplorer\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"cloudcode.unified.awsLambdaImporterExplorer\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"cloudcode.unified.cloudStorageExplorer\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"cloudcode.unified.sourceProtectExplorer\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"cloudcode.unified.mcdcSources\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"cloudcode.helpAndFeedbackExplorer\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"cloudcode.unified.dataprocExplorer\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"cloudcode.unified.notebookExplorer\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"cloudcode.unified.bigQueryDatasetExplorer\\\",\\\"isHidden\\\":false}]\",\"workbench.view.extension.1-geminiAIChatViewContainer.state.hidden\":\"[{\\\"id\\\":\\\"cloudcode.gemini.chatView\\\",\\\"isHidden\\\":false}]\",\"menu.hiddenCommands\":\"{\\\"EditorTitle\\\":[\\\"cloudcode.duetAI.actionsMenu\\\"]}\",\"workbench.auxiliarybar.pinnedPanels\":\"[{\\\"id\\\":\\\"workbench.panel.chatEditing\\\",\\\"pinned\\\":true,\\\"visible\\\":false,\\\"order\\\":101},{\\\"id\\\":\\\"workbench.panel.chat\\\",\\\"pinned\\\":true,\\\"visible\\\":false,\\\"order\\\":100}]\",\"views.customizations\":\"{\\\"viewContainerLocations\\\":{},\\\"viewLocations\\\":{},\\\"viewContainerBadgeEnablementStates\\\":{}}\",\"workbench.view.extension.references-view.state.hidden\":\"[{\\\"id\\\":\\\"references-view.tree\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"CppReferencesView\\\",\\\"isHidden\\\":false}]\",\"memento/workbench.editor.keybindings\":\"{\\\"searchHistory\\\":[\\\"ray\\\"]}\",\"fileBasedRecommendations/promptedRecommendations\":\"{\\\"plaintext\\\":[\\\"mechatroner.rainbow-csv\\\",\\\"tomoki1207.pdf\\\"]}\",\"workbench.chat.hideMovedChatWelcomeView\":\"true\"}}"}